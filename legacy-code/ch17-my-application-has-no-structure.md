# Chapter 17: 내 애플리케이션은 뼈대가 약하다 (My Application Has No Structure)

## 핵심 질문

아키텍처 수준에서 구조가 보이지 않는 대규모 애플리케이션을 어떻게 이해하고, 숨겨진 구조를 발견하며, 점진적으로 개선할 수 있는가?

---

## 1. 구조 부재의 문제

Chapter 16이 개별 코드 수준의 이해를 다루었다면, 이 장은 **시스템 전체 수준의 구조**를 다룬다. 대규모 레거시 시스템에서 흔히 마주치는 상황은 다음과 같다:

- 시스템에 **명확한 아키텍처가 없다**
- 모듈이나 패키지는 있지만, **논리적인 구분이 아닌 물리적인 편의**에 의해 나뉘어져 있다
- 새로운 기능을 어디에 추가해야 할지 **합의된 기준이 없다**
- 팀원마다 시스템에 대한 **다른 멘탈 모델**을 가지고 있다

### 1.1 구조 부재의 증상

| 증상 | 설명 |
|------|------|
| **새 기능의 위치 결정이 어렵다** | "이 기능은 어느 패키지에 넣어야 하지?" 라는 질문에 명확한 답이 없다 |
| **유사한 코드가 여러 곳에 존재한다** | 같은 개념이 다른 이름, 다른 구현으로 여러 곳에 흩어져 있다 |
| **변경의 파급 효과를 예측할 수 없다** | 한 곳을 변경하면 예상치 못한 곳이 깨진다 |
| **팀원 간 의사소통이 어렵다** | "주문 처리 모듈"이라는 말이 팀원마다 다른 코드를 가리킨다 |
| **시스템의 "큰 그림"을 설명할 수 없다** | 시스템이 무엇을 하는지 간결하게 설명하기 어렵다 |

### 1.2 구조 부재의 근본 원인

구조가 없어진 것은 대부분 하루아침에 일어난 일이 아니다. 점진적으로 악화된 결과다:

1. **초기 설계가 없었거나 매우 미약했다**: 프로토타입이 그대로 프로덕션이 되었다.
2. **설계 원칙 없이 기능만 추가했다**: 마감 압박 속에서 "일단 동작하게" 만들었다.
3. **팀원이 교체되면서 일관성이 사라졌다**: 각자 다른 스타일과 구조 인식을 가지고 코드를 추가했다.
4. **리팩토링 없이 성장했다**: 시스템이 커질 때마다 구조를 재정비해야 하는데, 이를 하지 않았다.

---

## 2. 기법 1: Telling the Story of the System

### 2.1 개요

가장 강력하면서도 간단한 기법이다. 시스템을 **다른 사람에게 이야기하듯 설명**하는 것이다. 핵심은 **간결함**이다. 세부사항은 과감히 생략하고, 시스템의 본질만 추출하여 설명한다.

### 2.2 방법

한 사람이 다른 사람에게 시스템을 설명한다. 설명을 듣는 사람은 다음과 같은 규칙을 적용한다:

> **"너무 세부적이야. 더 간결하게 말해줘."**

이 압력이 핵심이다. 설명하는 사람이 세부사항에 빠지려 할 때마다, 듣는 사람이 더 높은 수준의 추상화를 요구한다.

### 2.3 구체적 예시

**나쁜 예 (너무 세부적):**

```
"우리 시스템은요, 먼저 HTTP 요청이 들어오면 Servlet이 받아서
RequestParser 클래스에서 파싱하고, 그 결과를 HashMap에 넣어서
OrderController에 전달하는데, OrderController는 OrderService를
호출하고, OrderService는 먼저 CustomerDAO에서 고객 정보를
조회하고, 그 다음에 InventoryDAO에서 재고를 확인하고..."
```

**좋은 예 (간결하게):**

```
"우리 시스템은 온라인 주문 처리 시스템이야.
크게 네 가지 일을 해:
1. 고객이 상품을 주문한다
2. 결제를 처리한다
3. 창고에 출고를 요청한다
4. 고객에게 배송 상태를 알려준다

그리고 관리자가 상품과 재고를 관리하는 백오피스가 있어."
```

### 2.4 이야기에서 구조를 발견하기

간결한 이야기를 완성하면, 그 이야기 자체가 시스템의 구조를 드러낸다:

```
[이야기에서 발견된 구조]

"온라인 주문 처리 시스템"
├── 주문 (Order)
│     ├── 주문 접수
│     └── 주문 이력 관리
├── 결제 (Payment)
│     ├── 결제 처리
│     └── 환불 처리
├── 출고 (Fulfillment)
│     ├── 창고 출고 요청
│     └── 배송 추적
├── 알림 (Notification)
│     ├── 주문 확인 알림
│     └── 배송 상태 알림
└── 백오피스 (Back Office)
      ├── 상품 관리
      └── 재고 관리
```

이 구조가 현재 코드의 패키지 구조와 일치하지 않는다면, 그것 자체가 중요한 발견이다. 코드의 물리적 구조와 논리적 구조 사이의 간극이 구조 부재의 원인일 수 있다.

### 2.5 의도적 단순화의 가치

> 시스템을 이야기할 때 정확성보다 간결성이 더 중요하다. "이것은 정확하지 않은데..."라는 유혹을 이겨내야 한다.

세부사항을 과감히 생략하면, 시스템의 **본질적인 개념**만 남는다. 이 본질적 개념들이 바로 시스템의 아키텍처가 되어야 할 것들이다. 현재 코드에 이 개념들이 명시적으로 표현되어 있지 않다면, 그것이 리팩토링의 방향을 알려준다.

---

## 3. 기법 2: CRC Cards (Class-Responsibility-Collaboration)

### 3.1 CRC 카드란?

**CRC(Class-Responsibility-Collaboration)** 카드는 Kent Beck과 Ward Cunningham이 객체 지향 설계를 탐색하기 위해 고안한 기법이다. 작은 인덱스 카드(3x5 인치)에 다음 세 가지를 적는다:

```
┌─────────────────────────────────┐
│ 클래스 이름 (Class Name)          │
├────────────────┬────────────────┤
│ 책임            │ 협력 대상       │
│ (Responsibilities) │ (Collaborators) │
│                │                │
│ - 책임 1        │ - 클래스 A     │
│ - 책임 2        │ - 클래스 B     │
│ - 책임 3        │               │
│                │                │
└────────────────┴────────────────┘
```

### 3.2 CRC 카드 작성 예시

메일링 리스트 서버 시스템의 CRC 카드를 작성한다면:

```
┌─────────────────────────────────┐
│ MailingListServer                │
├────────────────┬────────────────┤
│ - 메시지를 수신  │ - MessageReceiver │
│   하고 처리한다  │ - MessageDispatcher │
│                │                │
└────────────────┴────────────────┘

┌─────────────────────────────────┐
│ MessageDispatcher                │
├────────────────┬────────────────┤
│ - 메시지 유형을  │ - SubscriptionManager │
│   판단하여 적절한│ - MailingListMessage │
│   처리기로 전달  │                │
└────────────────┴────────────────┘

┌─────────────────────────────────┐
│ SubscriptionManager              │
├────────────────┬────────────────┤
│ - 구독자를       │ - SubscriberRepository │
│   추가/제거한다  │ - MailSender    │
│ - 구독 확인 메일 │                │
│   을 발송한다    │                │
└────────────────┴────────────────┘

┌─────────────────────────────────┐
│ SubscriberRepository             │
├────────────────┬────────────────┤
│ - 구독자를 저장  │ (없음 - 인터페이스)│
│   하고 조회한다  │                │
└────────────────┴────────────────┘
```

### 3.3 물리적 카드의 위력

CRC 카드가 디지털 도구(다이어그램 툴 등)보다 효과적인 이유가 있다:

1. **물리적 배치**: 카드를 테이블 위에 놓고, 관련 있는 카드들을 가까이 배치하면 **클러스터(cluster)** 가 자연스럽게 형성된다. 이 클러스터가 모듈이나 패키지의 후보가 된다.

2. **쉬운 재배치**: 카드를 옮기고, 그룹을 바꾸고, 새 카드를 추가하고, 카드를 제거하는 것이 매우 빠르다. 디지털 도구에서는 이 속도를 따라올 수 없다.

3. **팀 협업**: 여러 사람이 테이블 주위에 모여 카드를 배치하고 토론하면, 설계에 대한 **공유 이해(shared understanding)** 가 형성된다.

4. **물리적 제약**: 카드가 작으므로, 하나의 클래스에 너무 많은 책임을 적으면 공간이 부족해진다. 이 물리적 제약이 자연스럽게 **단일 책임 원칙(SRP)** 을 유도한다.

### 3.4 CRC 카드 세션 진행 방법

1. 팀원들이 테이블 주위에 모인다.
2. 시스템의 주요 클래스(또는 개념)를 각각 카드에 적는다.
3. 각 카드에 **책임**을 적는다. "이 클래스는 무엇을 하는가?"
4. 책임을 수행하기 위해 **다른 어떤 클래스와 협력하는가**를 적는다.
5. 카드를 테이블 위에 배치하며, 밀접한 관계의 카드를 가까이 놓는다.
6. 시나리오를 시뮬레이션한다: "주문이 들어오면, 이 카드가 이 카드를 호출하고..."
7. 책임이 불명확하거나, 한 카드에 너무 많은 책임이 있으면 카드를 분할한다.

---

## 4. 기법 3: Naked CRC

### 4.1 개요

**Naked CRC**는 일반 CRC 카드의 변형으로, **클래스 이름 없이 책임만 기록**하는 기법이다.

### 4.2 왜 클래스 이름을 제거하는가?

기존 시스템의 클래스 이름은 **선입견**을 만든다. 클래스 이름을 보면 무의식적으로 "이 클래스는 이런 일을 해야 한다"고 생각하게 되며, 기존 구조에 갇히게 된다.

예를 들어, `OrderManager`라는 이름을 보면 "주문 관리와 관련된 모든 것"이 이 클래스에 있어야 한다고 생각하기 쉽다. 하지만 실제로는 주문 검증, 주문 처리, 주문 이력 관리, 주문 알림 등이 별도의 책임일 수 있다.

### 4.3 Naked CRC 진행 방법

```
[일반 CRC]                      [Naked CRC]
┌───────────────────┐           ┌───────────────────┐
│ OrderManager      │           │ (이름 없음)        │
├───────────────────┤           ├───────────────────┤
│ - 주문 검증       │           │ - 주문의 유효성을  │
│ - 주문 처리       │   →       │   검사한다         │
│ - 재고 확인       │           └───────────────────┘
│ - 결제 처리       │           ┌───────────────────┐
│ - 알림 발송       │           │ (이름 없음)        │
└───────────────────┘           ├───────────────────┤
                                │ - 결제를 요청하고  │
                                │   결과를 확인한다  │
                                └───────────────────┘
                                ┌───────────────────┐
                                │ (이름 없음)        │
                                ├───────────────────┤
                                │ - 재고 가용성을    │
                                │   확인하고 예약한다│
                                └───────────────────┘
                                ... (더 많은 카드)
```

클래스 이름 없이 책임만 나열하면:
1. 하나의 거대한 클래스에 뭉쳐 있던 **책임들이 분리**된다.
2. 기존 클래스 구조에 대한 **선입견 없이** 순수하게 책임 중심으로 사고할 수 있다.
3. 책임들을 자연스럽게 그룹핑한 후, **나중에 적절한 이름을 부여**한다.

### 4.4 이름 부여 단계

Naked CRC에서 책임들을 그룹핑한 후, 각 그룹에 이름을 붙인다. 이때 기존 클래스 이름에 얽매이지 않고 **책임에 가장 잘 맞는 이름**을 선택한다:

```
[그룹핑된 책임]                    [새 이름 부여]

- 주문의 유효성을 검사한다          → OrderValidator
- 필수 항목이 모두 있는지 확인한다

- 결제를 요청하고 결과를 확인한다    → PaymentProcessor
- 결제 실패 시 재시도를 처리한다

- 재고 가용성을 확인하고 예약한다    → InventoryReserver
- 예약 실패 시 대기 목록에 추가한다

- 주문 확인 메일을 발송한다          → OrderNotifier
- 배송 상태 변경 시 알림을 보낸다
```

이렇게 하면 기존의 `OrderManager`라는 God 클래스가 각각 하나의 명확한 책임을 가진 네 개의 클래스로 분리된다.

---

## 5. 기법 4: Conversation Scrutiny (대화 면밀히 관찰하기)

### 5.1 개요

팀 내에서 이루어지는 **일상적 대화에서 사용하는 개념과 용어에 주목**하는 기법이다. 팀원들이 대화에서 사용하지만 코드에는 표현되지 않은 개념이 있다면, 그것은 아키텍처에 반영되어야 할 숨겨진 개념일 수 있다.

### 5.2 관찰 방법

팀 미팅, 코드 리뷰, 일상 대화에서 다음과 같은 패턴을 관찰한다:

**1) 코드에 없는 용어가 대화에서 반복적으로 등장한다**

```
[팀 대화]
"주문 검증 규칙을 바꿔야 해."
"할인 정책이 변경되었어."
"배송 추적 흐름에 문제가 있어."

[코드]
- "주문 검증 규칙"이라는 개념이 OrderService 메서드 안에 if문으로 흩어져 있다
- "할인 정책"이라는 클래스가 없고, 할인 로직이 여러 곳에 중복되어 있다
- "배송 추적 흐름"이 명시적 클래스나 모듈로 존재하지 않는다
```

이 경우, `OrderValidationRule`, `DiscountPolicy`, `ShipmentTracker` 같은 클래스가 코드에 존재해야 한다. 팀원들이 대화에서 이미 사용하는 개념이므로, 코드에 반영하면 코드와 도메인 사이의 간극이 줄어든다.

**2) 같은 대상을 다른 이름으로 부른다**

```
[팀 대화]
A: "사용자 계정을 업데이트해야 해."
B: "고객 프로필 변경 기능이지?"
C: "멤버 정보 수정 건 말이야?"
```

"사용자 계정", "고객 프로필", "멤버 정보"가 코드에서도 서로 다른 이름으로 존재한다면, 이것은 **용어의 불일치(Ubiquitous Language의 부재)** 를 나타낸다. 하나의 일관된 용어를 합의하고, 코드에 반영해야 한다.

**3) 설명이 복잡해지는 부분이 있다**

```
[팀 대화]
"그게, 주문이 들어오면 먼저 이것도 확인하고, 저것도 확인하고,
그런데 특별 고객이면 이 과정을 건너뛰고, 할인도 적용해야 하는데
할인이 두 가지 종류가 있어서..."
```

설명이 복잡해지는 부분은 코드에서도 복잡한 부분이다. 이런 복잡성은 명시적인 도메인 모델이 없기 때문에 발생하는 경우가 많다. 복잡한 개념을 클래스로 명시적으로 표현하면, 코드와 대화 모두 간결해진다.

### 5.3 대화에서 아키텍처를 개선하는 과정

```
[과정]

1. 대화에서 반복되는 개념/용어를 기록한다
2. 코드에서 이 개념이 어떻게 표현되어 있는지 확인한다
3. 코드에 명시적으로 표현되지 않은 개념을 식별한다
4. 이 개념들을 클래스, 모듈, 패키지로 코드에 도입한다
5. 팀 전체가 일관된 용어를 사용하도록 합의한다
```

이 과정은 Eric Evans의 Domain-Driven Design(DDD)에서 말하는 **유비쿼터스 언어(Ubiquitous Language)** 구축과 맥을 같이 한다. 팀의 대화 언어와 코드의 언어가 일치할 때, 의사소통의 비용이 줄고 코드의 의도가 명확해진다.

---

## 6. 구조 부재의 점진적 개선

### 6.1 한 번에 구조를 만들 수 없다

대규모 시스템의 구조를 한 번에 재설계하는 것은 현실적이지 않다. Feathers는 **점진적 개선**을 강조한다:

1. **현재 구조를 먼저 이해한다**: 위의 기법들을 활용하여 시스템의 현재 상태를 파악한다.
2. **목표 구조를 정한다**: Telling the Story와 CRC 카드를 통해 "있어야 할 구조"를 도출한다.
3. **간극을 식별한다**: 현재 구조와 목표 구조 사이의 차이를 파악한다.
4. **일상적인 변경 작업에서 점진적으로 이동한다**: 새 기능을 추가하거나 버그를 수정할 때마다, 조금씩 목표 구조에 가까워지도록 한다.

### 6.2 구조 개선의 실전 원칙

| 원칙 | 설명 |
|------|------|
| **큰 그림을 공유한다** | 팀 전체가 목표 구조에 대한 합의를 가져야 한다 |
| **모든 변경에서 구조를 의식한다** | 새 코드를 추가할 때 "이 코드는 목표 구조에서 어디에 위치하는가?"를 생각한다 |
| **완벽을 추구하지 않는다** | 현재보다 조금 나은 상태로 만드는 것이 목표다 |
| **큰 리팩토링을 한 번에 하지 않는다** | 작은 개선을 지속적으로 쌓아간다 |

### 6.3 네 가지 기법의 상호 관계

```
Telling the Story ──→ 시스템의 본질적 개념 도출
         │                        │
         ↓                        ↓
    CRC Cards ──────→ 개념을 클래스와 책임으로 구체화
         │                        │
         ↓                        ↓
    Naked CRC ──────→ 기존 선입견 없이 책임을 재분배
         │                        │
         ↓                        ↓
Conversation ───────→ 숨겨진 개념 발견, 용어 통일
Scrutiny                          │
                                  ↓
                        목표 아키텍처 도출
```

네 가지 기법은 모두 **시스템의 "있어야 할 구조"를 발견**하기 위한 것이다. 이 기법들을 통해 도출된 구조가 코드 리팩토링의 방향을 제시한다.

---

## 요약

- 아키텍처 수준에서 구조가 없는 시스템은 **변경, 이해, 의사소통** 모두를 어렵게 만든다.
- **Telling the Story of the System**: 시스템을 간결하게 이야기로 정리하면, 시스템의 본질적 개념과 구조가 드러난다. 세부사항은 과감히 생략한다.
- **CRC Cards**: 인덱스 카드에 클래스, 책임, 협력 관계를 적고 물리적으로 배치하면서 구조를 탐색한다. 물리적 카드의 조작 속도와 공간적 배치가 디지털 도구보다 유리하다.
- **Naked CRC**: 클래스 이름 없이 책임만 기록하여, 기존 구조에 대한 선입견을 제거하고 순수하게 책임 중심으로 사고한다.
- **Conversation Scrutiny**: 팀 대화에서 반복적으로 등장하지만 코드에 명시적으로 표현되지 않은 개념을 발견한다. 이는 유비쿼터스 언어 구축과 연결된다.
- 구조 개선은 **점진적으로** 이루어져야 한다. 일상적인 변경 작업에서 조금씩 목표 구조에 가까워지도록 한다.
- 네 가지 기법은 모두 시스템의 **"있어야 할 구조"를 발견**하기 위한 것이며, 이 구조가 리팩토링의 방향을 제시한다.

---

## 다음 챕터와의 연결

Chapter 18 "테스트 코드가 방해를 한다 (My Test Code Is in the Way)"에서는 테스트 코드 자체가 유지보수의 부담이 되는 상황을 다룬다. 테스트 코드의 양이 많아지면서 발생하는 문제들 — 테스트 코드의 중복, 깨지기 쉬운 테스트, 테스트 코드의 구조 관리 — 을 살펴보고, 테스트 코드를 효과적으로 관리하는 방법을 소개한다.
