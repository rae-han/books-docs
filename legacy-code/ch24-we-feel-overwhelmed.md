# Chapter 24: 어찌해야 할지 모르겠다. 나아질 것 같지 않아 (We Feel Overwhelmed. It Isn't Going to Get Any Better)

## 핵심 질문

거대하고 복잡한 레거시 코드베이스에 압도당했을 때, 어디서부터 시작해야 하는가? 모든 것을 한 번에 고칠 수 없다는 현실 앞에서, 어떤 태도와 전략으로 코드베이스를 점진적으로 개선해 나갈 수 있는가?

---

## 1. 압도감의 실체

### 1.1 레거시 코드에 압도당하는 이유

레거시 코드를 다루는 개발자들이 압도감을 느끼는 이유는 여러 가지이다:

**코드베이스의 규모와 복잡성:**
- 수십만, 수백만 줄의 코드가 테스트 없이 존재한다.
- 코드 간의 의존성이 복잡하게 얽혀 있어 한 부분을 이해하려면 다른 부분도 이해해야 한다.
- 문서가 없거나 오래되어 코드를 이해하는 유일한 방법은 코드 자체를 읽는 것뿐이다.

**변경에 대한 두려움:**
- 한 줄을 변경해도 어디서 무엇이 깨질지 예측할 수 없다.
- 테스트가 없으므로 변경 후 기존 동작이 보존되었는지 확인할 방법이 마땅치 않다.
- 과거에 코드를 변경했다가 장애가 발생한 경험이 트라우마로 작용한다.

**시작점을 찾을 수 없는 막막함:**
- "이 코드베이스를 개선하려면 어디서부터 시작해야 하지?"
- "전부 다시 작성해야 하는 것 아닌가?"
- "내가 할 수 있는 것이 있기는 한 건가?"

### 1.2 흔한 반응들

압도감에 대한 개발자와 팀의 반응은 몇 가지 패턴으로 나타난다:

| 반응 | 설명 | 결과 |
|------|------|------|
| **포기** | "이 코드는 손댈 수 없다" | 코드 품질이 계속 악화된다 |
| **전면 재작성** | "처음부터 다시 만들자" | 대부분 실패하거나, 새 레거시를 만든다 |
| **최소한의 변경** | "건드리지 않는 것이 안전하다" | 단기적으로는 안전하지만, 장기적으로 악화 |
| **비난** | "이전 개발자들이 잘못한 것이다" | 문제 해결에 도움이 되지 않는다 |

> 이 중 어느 것도 건설적인 해결책이 아니다. Feathers는 이 장에서 현실적이고 실행 가능한 대안을 제시한다.

---

## 2. 핵심 메시지: 한 번에 모든 것을 개선하려 하지 마라

이 장의 가장 중요한 메시지이다:

> 레거시 코드베이스를 한 번에 고치려고 하지 마라. 그것은 불가능하다. 대신, 변경이 필요한 부분을 변경할 때마다 조금씩 더 나은 상태로 만들어라.

전면 재작성(big rewrite)이 거의 항상 실패하는 이유:

1. **기존 시스템의 동작을 완전히 이해하고 재현하는 것이 불가능**하다. 레거시 코드에는 수년간 축적된 비즈니스 규칙, 엣지 케이스 처리, 버그 수정이 포함되어 있다. 이를 모두 파악하고 새 시스템에 반영하는 것은 비현실적이다.
2. **새 시스템을 개발하는 동안에도 기존 시스템은 유지보수해야** 한다. 두 시스템을 동시에 관리하는 것은 팀의 역량을 분산시킨다.
3. **새 시스템에도 결국 레거시가 된다.** 동일한 시간 압박과 기술 부채 축적 패턴이 반복된다.

---

## 3. 점진적 개선 전략

### 3.1 보이스카우트 규칙 (The Boy Scout Rule)

> 코드를 발견했을 때보다 조금 더 깨끗하게 남겨라.

이것은 Robert C. Martin이 표현한 원칙이지만, Feathers의 철학과 정확히 일치한다. 매번 코드를 변경할 때:

- 변경하는 부분의 **주변 코드를 조금 정리**한다.
- 가능하다면 **테스트를 하나라도 추가**한다.
- 의미 없는 변수 이름을 **명확한 이름으로 변경**한다.
- 작은 메서드를 **추출**한다.

이 작은 개선들이 시간이 지나면서 축적되면, 코드베이스가 **점진적으로 나아진다**.

### 3.2 변경하는 부분 주변만 개선하기

압도감의 주된 원인은 **코드베이스 전체를 바라보기 때문**이다. 전체를 보면 너무 거대하고 복잡해서 어디서 시작해야 할지 모른다.

핵심 전략은 **시야를 좁히는 것**이다:

```
[잘못된 접근]
전체 코드베이스를 보고 → "어디서부터?" → 압도감 → 포기

[올바른 접근]
지금 변경해야 할 부분만 보고 → 그 부분만 개선 → 작은 성공 → 다음 변경에서도 반복
```

지금 변경해야 할 기능이 `OrderProcessor` 클래스에 있다면:
1. `OrderProcessor`를 테스트 하네스에 넣는다.
2. 필요한 변경을 한다.
3. `OrderProcessor` 주변의 코드를 조금 정리한다.
4. 테스트를 추가한다.

다른 클래스가 아무리 엉망이어도 **지금은 신경 쓰지 않는다**. 나중에 그 클래스를 변경할 일이 생기면, 그때 그 클래스를 개선한다.

### 3.3 작은 승리(Small Wins)를 쌓아가기

작은 승리는 심리적으로 매우 중요하다:

- **테스트를 하나 추가**하는 것도 승리이다.
- **메서드를 하나 추출**하는 것도 승리이다.
- **변수 이름을 명확하게 변경**하는 것도 승리이다.
- **의존성을 하나 해제**하는 것도 승리이다.

이 작은 승리들이 쌓이면:
1. **코드가 실제로 나아진다** (객관적 개선).
2. **팀이 자신감을 얻는다** (심리적 개선).
3. **개선의 속도가 점점 빨라진다** (테스트가 있는 코드가 많아질수록 변경이 쉬워진다).

---

## 4. 팀 문화와 실천

### 4.1 새 코드는 반드시 테스트와 함께 작성

가장 중요한 팀 규칙이다:

> 새로 작성하는 모든 코드는 반드시 테스트를 갖추어야 한다.

기존 레거시 코드에 테스트를 한꺼번에 추가하는 것은 현실적으로 불가능하다. 하지만 **새로 작성하는 코드만큼은 테스트를 갖추겠다는 규칙은 즉시 실행할 수 있다**. 이 규칙을 지키면:

- 새 코드는 처음부터 **안전하게 변경 가능**한 상태로 시작한다.
- 시간이 지남에 따라 **테스트가 있는 코드의 비율이 자연스럽게 증가**한다.
- 레거시 코드와 테스트된 코드의 경계가 명확해져, 어디가 안전하고 어디가 위험한지 알 수 있다.

### 4.2 레거시 코드를 변경할 때마다 테스트를 추가

Chapter 2에서 소개한 레거시 코드 변경 알고리즘을 팀 전체가 따르는 것이 중요하다:

```
1. 변경 지점을 식별한다.
2. 테스트를 작성할 지점을 찾는다.
3. 의존성을 해제한다.
4. 테스트를 작성한다.
5. 변경하고 리팩토링한다.
```

이 절차를 매번 따르면, **레거시 코드가 변경될 때마다 테스트가 추가**된다. 자주 변경되는 코드일수록 빨리 테스트가 갖추어진다. 반면, 변경되지 않는 코드는 테스트가 없어도 괜찮다 (변경되지 않으므로 깨질 위험이 없다).

### 4.3 절대 완벽을 기다리지 말 것

> "시간이 나면 테스트를 추가하겠다", "나중에 대대적으로 리팩토링하겠다" — 이런 완벽한 시점은 오지 않는다.

완벽을 기다리는 것은 사실상 아무것도 하지 않겠다는 것과 같다. 대신:

- **지금 할 수 있는 작은 개선을 지금 한다.**
- 완벽한 테스트가 아니라 **불완전하더라도 있는 테스트가 없는 것보다 낫다.**
- 완벽한 설계가 아니라 **조금이라도 나아진 설계가 현재 설계보다 낫다.**

### 4.4 팀 전체의 합의

점진적 개선이 효과를 발휘하려면, **팀 전체가 이 철학에 동의해야** 한다:

- 코드 리뷰에서 **새 코드에 테스트가 없으면 지적**한다.
- 레거시 코드를 변경할 때 **테스트 추가를 격려**한다.
- 리팩토링에 시간을 투자하는 것을 **기술 부채 상환으로 인정**한다.
- **"빨리 하는 것"보다 "올바르게 하는 것"** 을 가치로 삼는다.

> 한 사람이 열심히 코드를 개선해도, 나머지 팀원이 테스트 없이 코드를 밀어넣으면 의미가 없다. 팀 문화가 바뀌어야 한다.

---

## 5. 기술 부채(Technical Debt)와의 관계

### 5.1 기술 부채의 비유

Ward Cunningham이 제안한 기술 부채의 비유는 레거시 코드의 상황을 잘 설명한다:

- **빚을 지는 것**: 테스트 없이, 설계를 타협하며 코드를 빠르게 작성하는 것. 단기적으로 속도를 얻지만, 장기적으로 이자를 지불해야 한다.
- **이자를 갚는 것**: 변경할 때마다 더 많은 시간과 노력이 드는 것. 코드가 복잡해질수록 이자율이 높아진다.
- **원금을 갚는 것**: 테스트를 추가하고, 코드를 리팩토링하고, 설계를 개선하는 것.

### 5.2 파산을 피하기

기술 부채가 감당할 수 없는 수준에 이르면 팀은 "파산" 상태에 빠진다:

- 어떤 변경도 할 수 없다.
- 변경할 때마다 새로운 버그가 발생한다.
- 개발자들이 프로젝트를 떠난다.
- 전면 재작성을 시도하지만 실패한다.

파산을 피하는 유일한 방법은 **꾸준히 원금을 갚는 것**, 즉 매 변경마다 조금씩 코드를 개선하는 것이다.

### 5.3 이자를 줄이는 실용적 방법

| 실천 | 효과 |
|------|------|
| 변경 시 테스트 추가 | 해당 부분의 이자율을 낮춤 |
| 메서드 추출 | 코드 이해 비용을 줄임 |
| 의존성 해제 | 변경 영향 범위를 줄임 |
| 명확한 이름 부여 | 코드 읽기 비용을 줄임 |
| Sprout/Wrap 기법 사용 | 새 부채를 만들지 않음 |

---

## 6. 희망적 메시지

Feathers는 이 장을 **희망적인 메시지**로 마무리한다.

### 6.1 시간은 편이다

점진적 개선의 가장 큰 장점은 **시간이 지남에 따라 효과가 누적**된다는 것이다:

```
[시간 경과에 따른 변화]

초기:   테스트 없는 코드 95% | 테스트 있는 코드 5%
6개월:  테스트 없는 코드 80% | 테스트 있는 코드 20%
1년:    테스트 없는 코드 60% | 테스트 있는 코드 40%
2년:    테스트 없는 코드 40% | 테스트 있는 코드 60%
```

자주 변경되는 핵심 코드가 먼저 테스트를 갖추게 되므로, **가장 중요한 부분의 안전성이 먼저 확보**된다.

### 6.2 변곡점이 온다

일정 수준의 테스트가 갖추어지면 **변곡점(tipping point)** 이 온다:

- 테스트가 있으니 **자신 있게 리팩토링**할 수 있다.
- 리팩토링하니 **코드 이해가 쉬워**진다.
- 코드 이해가 쉬우니 **변경이 빨라**진다.
- 변경이 빠르니 **더 많은 개선을 할 여유**가 생긴다.

이 선순환이 시작되면, 코드베이스는 빠르게 나아진다.

### 6.3 지금 시작하라

> 레거시 코드 개선을 시작하기에 가장 좋은 시점은 프로젝트 시작 때이다. 두 번째로 좋은 시점은 바로 지금이다.

코드베이스의 현재 상태가 아무리 나빠도, **지금부터 매 변경마다 조금씩 개선하면** 시간이 지남에 따라 반드시 나아진다. 중요한 것은 **시작하는 것**이고, **꾸준히 계속하는 것**이다.

---

## 요약

- 레거시 코드의 압도감은 코드베이스의 규모, 변경에 대한 두려움, 시작점을 찾을 수 없는 막막함에서 비롯된다.
- **한 번에 모든 것을 개선하려 하지 마라.** 전면 재작성은 거의 항상 실패한다.
- **보이스카우트 규칙**: 코드를 발견했을 때보다 조금 더 깨끗하게 남겨라.
- **변경하는 부분 주변만 개선**하고, 작은 승리를 쌓아가라.
- **새 코드는 반드시 테스트와 함께 작성**하라. 이것만으로도 테스트 커버리지가 자연스럽게 증가한다.
- **레거시 코드를 변경할 때마다 테스트를 추가**하라.
- 완벽한 시점을 기다리지 마라. **지금 할 수 있는 작은 개선을 지금 하라.**
- 팀 전체가 점진적 개선의 철학에 동의해야 효과가 있다.
- 꾸준히 하면 **시간이 지남에 따라 선순환이 시작**되고, 코드베이스는 점차 개선된다.

---

## 다음 챕터와의 연결

Chapter 25 **"의존 관계 제거 기법 (Dependency-Breaking Techniques)"** 에서는 이 책에서 가장 긴 장으로, 레거시 코드의 의존성을 해제하여 테스트를 가능하게 만드는 24가지 구체적 기법을 카탈로그 형태로 정리한다. 이전 장들에서 언급된 의존성 해제 기법들의 상세한 절차와 예시를 한곳에 모아 레퍼런스로 활용할 수 있게 구성되어 있다.
