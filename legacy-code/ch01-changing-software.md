# Chapter 1: 소프트웨어 변경 (Changing Software)

## 핵심 질문

소프트웨어를 변경하는 이유는 무엇이며, 변경의 종류에 따라 어떤 차이가 있는가?

---

## 1. 소프트웨어를 변경하는 네 가지 이유

소프트웨어를 변경하는 이유는 크게 네 가지로 분류할 수 있다:

| 변경 이유 | 설명 |
|-----------|------|
| **기능 추가 (Adding a feature)** | 새로운 능력(capability)을 시스템에 부여 |
| **버그 수정 (Fixing a bug)** | 기존 동작이 잘못된 부분을 교정 |
| **설계 개선 (Improving the design)** | 외부 동작은 유지하면서 내부 구조를 개선 (리팩토링) |
| **자원 사용 최적화 (Optimizing resource usage)** | 시간, 메모리 등 자원 사용 효율을 높임 |

### 1.1 기능 추가 vs 버그 수정: 관점의 차이

기능 추가와 버그 수정의 경계는 생각보다 모호하다. Feathers는 다음 예시를 든다:

> 웹 애플리케이션에서 회사 로고를 페이지 왼쪽에서 오른쪽으로 옮겨달라는 요청을 받았다. 이것은 버그 수정인가, 기능 추가인가?

- **고객 관점**: "화면이 잘못 보이니 고쳐달라" → **버그 수정**
- **개발자 관점**: "새로운 동작을 추가해야 한다" → **기능 추가**

이 구분이 중요한 이유는, **어느 쪽으로 분류하느냐에 따라 변경에 대한 태도와 접근 방식이 달라지기 때문**이다. 하지만 Feathers는 이 구분 자체보다 더 근본적인 분류 기준이 있다고 말한다.

### 1.2 더 근본적인 분류: 동작(Behavior)과 구조(Structure)

네 가지 변경 이유를 **동작 변경 여부**와 **구조 변경 여부**라는 두 축으로 재분류할 수 있다:

| | 구조 변경 | 구조 유지 |
|---|---|---|
| **동작 변경** | 기능 추가, 버그 수정 | (드묾) |
| **동작 유지** | 리팩토링 | 최적화 |

- **기능 추가**: 새로운 동작을 추가하고, 이를 위해 구조도 변경한다.
- **버그 수정**: 기존 동작을 바꾸고, 구조도 변경할 수 있다.
- **리팩토링**: 구조를 변경하지만, 외부 동작은 반드시 동일하게 유지해야 한다.
- **최적화**: 자원 사용 패턴을 바꾸지만, 동작과 구조 모두 가능한 한 유지한다.

> **핵심 통찰**: 리팩토링과 최적화에서 가장 중요한 제약은 **기존 동작을 보존(preserve behavior)** 하는 것이다.

---

## 2. 기존 동작의 보존이 핵심이다

Feathers가 이 장에서 가장 강조하는 메시지:

> **소프트웨어 변경에서 가장 어려운 일은 기존 동작을 보존하면서 변경하는 것이다.**

### 2.1 보존해야 할 동작의 범위

변경 유형에 따라 보존해야 할 동작의 범위가 다르다:

- **기능 추가**: 기존의 모든 동작은 그대로 유지하면서, 새로운 동작만 추가해야 한다.
- **버그 수정**: 대부분의 동작은 유지하면서, 잘못된 동작 하나만 바꿔야 한다.
- **리팩토링**: 모든 동작을 100% 동일하게 유지해야 한다.
- **최적화**: 모든 동작을 동일하게 유지하면서, 자원 사용만 변경한다.

어떤 유형이든 **보존해야 할 동작이 매우 많고, 변경할 동작은 적다**는 공통점이 있다. 문제는 우리가 보존해야 할 동작을 의도치 않게 깨뜨리는 경우가 너무 자주 발생한다는 것이다.

### 2.2 변경의 위험성

코드를 변경할 때의 위험은 다음과 같다:

1. **변경해야 할 동작을 올바르게 변경하지 못할 위험**
2. **보존해야 할 기존 동작을 의도치 않게 깨뜨릴 위험**

두 번째 위험이 레거시 코드에서 특히 치명적이다. 레거시 코드는 테스트가 없거나 부족해서, 기존 동작이 보존되었는지 확인할 방법이 마땅치 않기 때문이다.

---

## 3. 변경은 피할 수 없다

많은 팀이 변경의 위험성 때문에 코드 변경을 최소화하려 한다. 이는 몇 가지 형태로 나타난다:

- **"동작하는 코드는 건드리지 마라"** 라는 문화
- 변경 시 최소한의 코드만 수정하고, 가능하면 기존 코드 옆에 새 코드를 덧붙이는 방식
- 충분한 구조 개선 없이 기능만 급하게 추가

이런 접근은 단기적으로는 안전해 보이지만, **장기적으로 코드의 품질을 계속 악화시킨다**. 코드는 점점 이해하기 어려워지고, 변경은 점점 위험해지는 악순환에 빠진다.

---

## 4. 핵심 개념: "변경을 안전하게 만드는 것"

이 장의 결론이자 책 전체의 핵심 전제:

> 코드 변경을 피할 수 없다면, **변경을 안전하게 만드는 기법**을 갖춰야 한다.

그리고 변경을 안전하게 만드는 핵심 도구가 바로 **테스트**다. 이 책의 나머지 부분은 레거시 코드에 테스트를 추가하고, 테스트의 보호 아래 안전하게 코드를 변경하는 기법들을 다룬다.

---

## 요약

- 소프트웨어 변경에는 네 가지 이유(기능 추가, 버그 수정, 리팩토링, 최적화)가 있다.
- 모든 변경에서 공통적으로 가장 어려운 것은 **기존 동작을 보존하는 것**이다.
- 변경을 피하는 것은 해결책이 아니다. 오히려 코드 품질을 악화시킨다.
- 변경을 **안전하게 수행**할 수 있는 능력이 필요하며, 그 핵심은 **테스트**다.
- 이 책은 레거시 코드에서 테스트를 추가하고 안전하게 변경하는 방법을 다룬다.

---

## 다음 챕터와의 연결

Chapter 2 **"피드백 활용 (Working with Feedback)"** 에서는 변경을 안전하게 만드는 핵심 도구인 **단위 테스트(unit testing)** 와 **테스트 주도 편집(edit-test cycle)** 을 본격적으로 소개한다.
