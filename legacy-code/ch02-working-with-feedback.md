# Chapter 2: 피드백 활용 (Working with Feedback)

## 핵심 질문

코드를 변경할 때 어떻게 하면 기존 동작이 보존되었는지 확신할 수 있는가? 변경에 대한 피드백을 얻는 가장 효과적인 방법은 무엇인가?

---

## 1. 시스템 변경의 두 가지 방식

소프트웨어를 변경하는 접근 방식은 크게 두 가지로 나눌 수 있다.

### 1.1 Edit and Pray (편집하고 기도하기)

**Edit and Pray**는 업계에서 가장 흔한 코드 변경 방식이다. 다음과 같은 과정을 거친다:

1. 변경할 코드를 **신중하게 계획**한다.
2. 코드를 **이해했다고 확신**한 후 변경한다.
3. 변경 후 시스템을 실행해보며 **제대로 동작하는지 확인**한다.
4. 문제가 없기를 **기도한다**.

이 방식은 "신중하게 작업하기(working with care)"로 포장되기도 한다. 물론 신중함 자체는 전문가의 덕목이다. 하지만 **신중함만으로는 안전망이 될 수 없다**. 아무리 신중하게 외과 수술을 계획하더라도, 수술 과정에서 환자의 상태를 모니터링하는 장비 없이 수술하는 외과의사는 없다.

> Edit and Pray는 대부분의 레거시 코드 작업이 이루어지는 방식이다. 신중한 계획이 있더라도, 변경의 영향을 확인할 수단이 없다면 그것은 "전문성"이 아니라 "운"에 의존하는 것이다.

### 1.2 Cover and Modify (덮고 수정하기)

**Cover and Modify**는 변경할 코드 영역을 **테스트로 덮은(cover) 후**, 테스트의 보호 아래 코드를 수정하는 방식이다.

이 방식의 핵심 비유는 **안전망(safety net)** 이다:

- 서커스에서 공중그네 곡예사가 고난도 동작을 시도할 수 있는 것은 아래에 안전망이 있기 때문이다.
- 마찬가지로, 개발자가 코드를 대담하게 수정할 수 있는 것은 변경이 기존 동작을 깨뜨리면 테스트가 즉시 알려주기 때문이다.

| 비교 항목 | Edit and Pray | Cover and Modify |
|-----------|--------------|-----------------|
| **피드백 수단** | 수동 확인, 감에 의존 | 자동화된 테스트 |
| **변경 자신감** | 낮음 | 높음 |
| **오류 발견 시점** | 배포 후 또는 한참 뒤 | 변경 직후 (수 초 이내) |
| **대담한 리팩토링** | 위험해서 시도 불가 | 안전망이 있으므로 가능 |
| **코드 품질 추세** | 시간이 갈수록 악화 | 점진적 개선 가능 |

> **핵심 통찰**: 좋은 테스트를 갖추면 코드 변경이 "겁나는 일"에서 "일상적인 작업"으로 바뀐다.

---

## 2. 테스트를 통한 피드백

Cover and Modify의 핵심은 **테스트가 제공하는 빠른 피드백**이다. 변경을 하고, 테스트를 돌리면, 기존 동작이 보존되었는지 즉시 확인할 수 있다.

### 2.1 피드백 루프(Feedback Loop)

테스트를 통한 피드백 루프는 다음과 같다:

```
코드 변경 → 테스트 실행 → 결과 확인
    ↑                         ↓
    ←── 실패 시 즉시 수정 ────←
```

이 루프가 빠를수록(즉, 테스트가 빨리 실행될수록) 개발자는 더 자주 피드백을 받을 수 있고, 더 자신 있게 코드를 변경할 수 있다.

### 2.2 회귀 테스트 (Regression Testing)

**회귀 테스트(Regression Testing)** 란 변경 후 기존에 동작하던 기능이 여전히 올바르게 동작하는지 확인하는 테스트다. "회귀(regression)"란 이전에 동작하던 것이 더 이상 동작하지 않는 상태를 말한다.

회귀 테스트는 크게 다음 수준에서 이루어질 수 있다:

| 수준 | 설명 | 예시 |
|------|------|------|
| **애플리케이션 수준** | 전체 시스템을 GUI나 API를 통해 테스트 | QA 팀의 수동/자동 회귀 테스트 |
| **통합 수준** | 여러 컴포넌트를 함께 테스트 | DB, 네트워크를 포함한 테스트 |
| **단위 수준** | 개별 클래스나 함수를 격리하여 테스트 | JUnit, NUnit 등의 단위 테스트 |

회귀 테스트 자체는 좋은 아이디어지만, **애플리케이션 수준에서만 수행되는 회귀 테스트에는 심각한 한계**가 있다:

1. **느리다**: 전체 시스템을 부팅하고, GUI를 조작하고, 결과를 확인하는 데 시간이 많이 걸린다.
2. **오류 위치를 특정하기 어렵다**: 테스트가 실패해도 수많은 코드 중 어디가 문제인지 파악하기 힘들다.
3. **피드백이 늦다**: 테스트 사이클이 길기 때문에 변경과 피드백 사이의 시간 간격이 크다.

---

## 3. 단위 테스트 (Unit Testing)

Feathers는 레거시 코드 작업에서 가장 효과적인 피드백 수단으로 **단위 테스트(Unit Test)** 를 강조한다.

### 3.1 단위 테스트의 정의

"단위 테스트"라는 용어는 소프트웨어 개발 역사에서 다양한 의미로 사용되어 왔다. 어떤 사람은 단일 함수를 테스트하는 것을 단위 테스트라 하고, 어떤 사람은 모듈 단위의 테스트를 단위 테스트라 한다. Feathers는 다음과 같이 정의한다:

**단위 테스트란 격리된 환경에서 소프트웨어의 개별 구성 요소를 검증하는 테스트다.**

여기서 핵심 키워드는 **"격리(isolation)"** 다.

### 3.2 단위 테스트의 특성

Feathers가 규정하는 단위 테스트의 핵심 특성은 다음과 같다:

1. **빠르게 실행된다 (Fast)**
2. **오류 위치를 특정할 수 있다 (Localize errors)**
3. **격리된 환경에서 실행된다 (Run in isolation)**

특히 **속도**에 대해 Feathers는 매우 구체적인 기준을 제시한다:

> **0.1초(1/10초) 이상 걸리는 테스트는 단위 테스트가 아니다.** 그것은 느린 테스트다.

이것이 극단적으로 보일 수 있지만, Feathers의 논리는 명확하다:

```
테스트 1개 × 0.1초 = 별 문제 없어 보인다
테스트 3,000개 × 0.1초 = 300초 = 5분
테스트 3,000개 × 0.01초 = 30초
```

5분이면 개발자는 테스트를 "필요할 때만" 실행하게 된다. 30초라면 습관적으로 자주 실행할 수 있다. **피드백 루프의 속도가 곧 개발 품질**이다.

### 3.3 빠른 테스트가 아닌 것들

Feathers는 다음 작업을 수행하는 테스트는 단위 테스트가 아니라고 명확히 선을 긋는다:

| 느린 요소 | 이유 |
|-----------|------|
| **데이터베이스에 접근한다** | DB 연결, 쿼리 실행, 트랜잭션 처리 모두 시간이 걸린다 |
| **네트워크를 통해 통신한다** | 네트워크 지연, 서버 응답 대기 시간이 존재한다 |
| **파일 시스템에 접근한다** | 파일 I/O는 메모리 연산보다 현저히 느리다 |
| **특별한 환경 설정이 필요하다** | 설정 파일 편집, 환경 변수 설정 등이 필요하면 격리되지 않은 것이다 |

이런 테스트들이 **나쁜 테스트라는 의미가 아니다**. 이들은 통합 테스트나 시스템 테스트로서 분명히 가치가 있다. 하지만 이들은 **단위 테스트와 분리해서 관리**해야 한다. 단위 테스트 스위트에 느린 테스트가 섞이면, 전체 테스트 스위트가 느려지고, 개발자는 테스트 실행을 꺼리게 된다.

### 3.4 단위 테스트 vs 더 큰 테스트

| 특성 | 단위 테스트 | 통합/시스템 테스트 |
|------|-----------|-------------------|
| **실행 속도** | 매우 빠름 (0.1초 미만/개) | 느림 (수 초~수 분) |
| **오류 위치 특정** | 정확함 (특정 클래스/메서드) | 모호함 (어디서 실패했는지 추적 필요) |
| **격리 수준** | 완전 격리 (외부 의존성 없음) | 여러 컴포넌트 함께 실행 |
| **실행 빈도** | 매 변경마다 (수십 초) | 빌드 시 또는 주기적 |
| **피드백 가치** | 즉각적, 구체적 | 전체적, 포괄적 |

두 종류의 테스트 모두 필요하지만, **레거시 코드를 변경하는 일상적 작업에서 빠른 피드백을 제공하는 것은 단위 테스트**다.

---

## 4. 레거시 코드의 딜레마 (The Legacy Code Dilemma)

이 장에서 가장 중요한 개념 중 하나가 바로 **레거시 코드의 딜레마**다.

> **코드를 변경하려면 테스트가 필요하다. 그런데 테스트를 넣으려면 코드를 변경해야 한다.**

이 딜레마를 구체적으로 풀어보면 다음과 같다:

```
[현재 상태]
레거시 코드: 테스트 없음, 의존성 복잡

[목표]
테스트를 추가하여 안전하게 변경하고 싶다

[문제]
테스트를 작성하려면 → 클래스를 테스트 하네스에 넣어야 한다
                   → 의존성을 끊어야 한다 (DB, 네트워크, 다른 클래스 등)
                   → 의존성을 끊으려면 코드를 변경해야 한다
                   → 코드를 변경하면 기존 동작이 깨질 위험이 있다
                   → 기존 동작을 보호하려면 테스트가 필요하다
                   → (처음으로 돌아감)
```

이것은 닭과 달걀의 문제처럼 보인다. 하지만 Feathers는 **이 딜레마를 풀 수 있다**고 말한다. 핵심은 다음과 같다:

### 4.1 딜레마를 풀어나가는 방법

1. **매우 보수적이고 안전한 코드 변경 기법**을 사용하여 최소한의 변경으로 의존성을 끊는다.
2. 의존성이 끊어지면 **테스트를 작성**한다.
3. 테스트가 있으면 **더 대담한 변경**을 안전하게 수행할 수 있다.

즉, 처음에는 "테스트 없이 코드를 변경"해야 하는 것이 사실이다. 하지만 이때 수행하는 변경은:

- **매우 작고 (very small)**
- **매우 보수적이며 (very conservative)**
- **구조적으로 안전한 (structurally safe)** 변경이다.

이 책의 나머지 부분은 이런 "안전한 초기 변경" 기법들을 구체적으로 다룬다. 예를 들어:

- **Seam(이음새)** 을 찾아 의존성을 교체할 수 있는 지점을 만든다 (Chapter 4)
- **Extract Method**, **Extract Interface** 같은 안전한 리팩토링을 수행한다
- **자동화된 리팩토링 도구**를 활용하여 사람의 실수를 줄인다 (Chapter 5)

---

## 5. 변경 알고리즘 (The Legacy Code Change Algorithm)

Feathers는 레거시 코드에서의 작업 절차를 다음과 같은 **알고리즘**으로 정리한다:

### 레거시 코드 변경 알고리즘

1. **변경 지점을 식별한다 (Identify change points)**
   - 어디를 변경해야 하는지 파악한다.

2. **테스트 지점을 찾는다 (Find test points)**
   - 변경에 대한 테스트를 어디에 작성할 수 있는지 찾는다.

3. **의존성을 깨뜨린다 (Break dependencies)**
   - 테스트를 작성하기 위해 필요한 최소한의 의존성을 끊는다.

4. **테스트를 작성한다 (Write tests)**
   - 기존 동작을 문서화하는 테스트를 작성한다.

5. **변경하고 리팩토링한다 (Make changes and refactor)**
   - 테스트의 보호 아래 원래 목적의 변경을 수행한다.

이 알고리즘은 이 책 전체를 관통하는 기본 프레임워크다. 각 챕터는 이 알고리즘의 특정 단계를 깊이 있게 다룬다.

```
  ┌──────────────────────────────────────────┐
  │  1. 변경 지점 식별                         │
  │     (어디를 바꿔야 하나?)                   │
  └──────────────┬───────────────────────────┘
                 ↓
  ┌──────────────────────────────────────────┐
  │  2. 테스트 지점 찾기                       │
  │     (어디에 테스트를 넣을 수 있나?)          │
  └──────────────┬───────────────────────────┘
                 ↓
  ┌──────────────────────────────────────────┐
  │  3. 의존성 깨뜨리기                        │
  │     (테스트를 위한 최소한의 코드 변경)        │
  └──────────────┬───────────────────────────┘
                 ↓
  ┌──────────────────────────────────────────┐
  │  4. 테스트 작성                            │
  │     (기존 동작을 문서화하는 테스트)           │
  └──────────────┬───────────────────────────┘
                 ↓
  ┌──────────────────────────────────────────┐
  │  5. 변경 및 리팩토링                       │
  │     (테스트의 보호 아래 안전하게 변경)        │
  └──────────────────────────────────────────┘
```

---

## 요약

- 시스템 변경 방식은 **Edit and Pray**(편집하고 기도하기)와 **Cover and Modify**(덮고 수정하기) 두 가지로 나뉜다.
- Edit and Pray는 대부분의 레거시 코드 작업이 이루어지는 방식이지만, 안전성이 보장되지 않는다.
- Cover and Modify는 테스트라는 안전망을 먼저 설치하고 변경하는 방식이다.
- **회귀 테스트**는 유용하지만, 애플리케이션 수준에서만 수행하면 느리고 오류 위치를 특정하기 어렵다.
- **단위 테스트**는 빠르고, 오류 위치를 정확히 알려주며, 격리된 환경에서 실행된다.
- Feathers의 기준: **0.1초 이상 걸리면 단위 테스트가 아니다.**
- DB 접근, 네트워크 통신, 파일시스템 접근, 환경 설정이 필요한 테스트는 단위 테스트가 아니다.
- **레거시 코드의 딜레마**: 코드를 변경하려면 테스트가 필요하고, 테스트를 넣으려면 코드를 변경해야 한다.
- 이 딜레마는 **매우 보수적이고 안전한 코드 변경 기법**으로 풀어나갈 수 있다.
- **레거시 코드 변경 알고리즘**: 변경 지점 식별 → 테스트 지점 찾기 → 의존성 깨뜨리기 → 테스트 작성 → 변경 및 리팩토링.

---

## 다음 챕터와의 연결

Chapter 3 **"감지와 분리 (Sensing and Separation)"** 에서는 의존성을 깨뜨려야 하는 두 가지 구체적인 이유 — 코드가 수행하는 동작을 **감지(Sensing)** 할 수 없는 경우와, 테스트 대상 코드를 다른 코드로부터 **분리(Separation)** 할 수 없는 경우 — 를 살펴보고, 가짜 객체(Fake Object)와 Mock Object를 사용하여 이 문제를 해결하는 방법을 소개한다.
