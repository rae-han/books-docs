# 사례 연구: TVING 웹 모노레포 버전 마이그레이션과 레거시 코드 원칙

## 개요

이 문서는 TVING 웹 모노레포의 대규모 버전 마이그레이션(WC-194) 작업이 "Working Effectively with Legacy Code"의 어떤 원칙들과 연결되는지를 분석합니다.

### 마이그레이션 요약

| Phase | 대상 | 변경 | 상태 |
|-------|------|------|------|
| 1 | Yarn | 3.3.1 → 4.12.0 | 완료 |
| 2 | Node.js | 18.20.4 → 22.13.1 | 완료 |
| 3 | TypeScript | 4.x → 5.9.3 | 완료 |
| 4 | React | 앱별 독립 관리 전환 | 완료 |
| 5 | Next.js (Account/Bill) | 14.2.3 → 15 | 완료 |
| 6 | Next.js (PC) | 12.3.1 → 12.3.7 (패치만) | 제안 |

### 핵심 마이그레이션 원칙

Phase 순서를 결정한 두 가지 독립된 원칙이 있다:

**원칙 A — 독립적인 변경을 먼저** → Ch07, Ch23

다른 변경과 순서 의존성이 없는 것을 먼저 처리한다. 실패해도 다른 변경에 영향을 주지 않고, 원인 파악이 쉽다.

- **Yarn 3→4**: Node 버전과 무관하게 업그레이드 가능하다. Yarn 4는 Node 18에서도 22에서도 동작한다. 반면 Node를 먼저 올리면, Yarn 3의 PnP 환경에서 네이티브 모듈 빌드가 실패할 때 Node 문제인지 Yarn 문제인지 분리할 수 없다.
- **TypeScript 4→5**: 빌드 타임에서만 영향이 있고, 런타임 동작을 바꾸지 않는다. React 버전과도 직접적인 의존 관계가 없다.

**원칙 B — 하위 계층부터 상위 계층으로** → Ch07

실제 계층 의존성이 있는 것들 사이에서는 하위(런타임)를 먼저 안정화한 뒤 상위(프레임워크)를 변경한다.

- **Node 18→22**: 런타임 기반. 모든 것이 이 위에서 동작한다.
- **React 18→19**: UI 라이브러리. Next.js가 이 위에서 동작한다.
- **Next.js 14→15**: 최상위 프레임워크. Node와 React 위에서 동작한다.

참고로, 계층 관계가 없는 쌍도 있다:
- **Yarn ↔ Node**: Yarn은 Node 위에서 동작하는 도구이지만, 업그레이드 자체는 서로 독립적이다. 계층 순서대로라면 Node가 먼저여야 하지만, 독립성 원칙(원칙 A)에 따라 Yarn이 먼저다.
- **TypeScript ↔ React**: 빌드 도구와 런타임 라이브러리는 서로 다른 차원이라 계층 상하 관계가 아니다.

**두 원칙의 조합으로 도출된 최종 순서:**

```
독립적 변경          계층적 변경 (하위→상위)

Yarn 3→4             Node 18→22
TypeScript 4→5           ↓
                     React 18→19
                         ↓
                     Next.js 14→15
```

이를 하나의 실행 순서로 배치하면:

```
Yarn → Node → TypeScript → React → Next.js
```

- Yarn: 가장 독립적이므로 가장 먼저
- Node: 계층적 변경의 출발점 (런타임 기반)
- TypeScript: 독립적이지만, Node 안정화 후 실행하면 컴파일러가 이후 React/Next.js 변경의 오류를 잡아줌
- React → Next.js: 계층 순서 (React가 Next.js보다 하위)

그 외 원칙:
- **변경의 독립성 확보**: Phase별로 분리하여 문제 원인 즉시 파악, 롤백 가능 → Ch23
- **각 Phase마다 PoC로 빌드/실행 검증** → Ch02

---

## 깊은 관련: 핵심 원칙이 직접 적용된 챕터

### Chapter 1: 소프트웨어 변경 — "보존해야 할 동작이 훨씬 많다"

이 챕터는 소프트웨어 변경의 네 가지 이유(기능 추가, 버그 수정, 리팩토링, 최적화)를 분류하고, 모든 변경에서 가장 어려운 것은 **기존 동작을 보존하는 것**이라고 강조한다.

이번 마이그레이션은 "최적화"에 해당한다. 런타임과 프레임워크를 최신화하되, 사용자가 보는 동작은 100% 동일하게 유지해야 한다. 변경할 것(버전)은 적고, 보존해야 할 것(전체 서비스 동작)은 압도적으로 많은 전형적 사례다.

각 Phase마다 "PoC로 빌드/실행 정상 확인"을 거친 것이 이 원칙의 실천이다. Phase 6에서 PC Next.js 15를 보류한 것도, 160개 파일 변경 시 기존 동작 보존을 보장하기 어렵다는 판단에 기반한다.

### Chapter 7: 코드 하나 바꾸는 데 왜 이리 오래 걸리지? — "의존성 체인이 변경을 느리게 만든다"

이 챕터는 변경이 오래 걸리는 핵심 원인으로 **의존성의 복잡성**을 지목한다. 하나의 모듈을 바꾸면 그것에 의존하는 모든 모듈이 영향을 받고, 빌드 시간이 길어지며, 변경의 영향 범위를 파악하기 어려워진다.

이번 마이그레이션의 Phase 순서는 두 가지 독립된 원칙의 조합으로 결정되었다:

```
독립적 변경          계층적 변경 (하위→상위)

Yarn 3→4             Node 18→22
TypeScript 4→5           ↓
                     React 18→19
                         ↓
                     Next.js 14→15
```

**원칙 A: 독립적인 변경을 먼저.** Yarn 3→4는 Node 버전에 의존하지 않는다(Node 18, 22 모두에서 동작). TypeScript 4→5는 빌드 타임에서만 변경이 있고 런타임에 영향을 주지 않는다. 이런 독립적인 변경은 실패해도 다른 변경에 영향을 주지 않으므로, 원인 파악과 롤백이 쉽다.

**원칙 B: 하위 계층부터 상위 계층으로.** Node(런타임) → React(UI 라이브러리) → Next.js(프레임워크)에는 실제 계층 의존성이 있다. 상위 계층은 하위 계층 위에서 동작하므로, 하위를 먼저 안정화해야 상위 변경 시 문제가 생겨도 원인이 하위가 아닌 상위에 있다는 것을 확신할 수 있다. 참고로 Yarn↔Node, TypeScript↔React는 서로 다른 차원(도구 vs 런타임, 빌드 도구 vs UI 라이브러리)이라 계층 상하 관계가 성립하지 않는다.

이 챕터는 또한 "빌드 시간을 줄이면 개발 방식 자체가 바뀐다"고 말한다. Yarn 4의 ~4배 빌드 속도 개선은 개발자가 더 자주 검증하고, 더 작은 단위로 변경할 수 있는 환경을 만들어준다.

### Chapter 14: 나를 미치게 하는 라이브러리 의존 관계 — "라이브러리를 직접 뿌리지 말고 감싸라"

이 챕터의 핵심 원칙은 **"소유하지 않은 코드(라이브러리)에 직접 의존하지 말고, 한 단계 래핑하라"** 이다. 라이브러리의 concrete 클래스에 직접 의존하면 라이브러리 교체 시 전체 코드를 수정해야 한다.

`node-sass → dart-sass` 전환이 이 문제의 전형적 사례다. Node 22가 node-sass의 네이티브 바이너리를 더 이상 지원하지 않아 dart-sass로 교체해야 했다. 만약 sass 호출이 래퍼 레이어 뒤에 있었다면 교체 비용이 더 적었을 것이다.

루트 `resolutions`로 React 버전을 강제 통일하던 구조도 이 문제의 연장선이다. 모든 앱이 하나의 라이브러리 버전에 직접 묶여 있으면, 앱별로 독립적인 업그레이드가 불가능해진다. 이를 **앱별 독립 관리**로 전환한 것이 의존성 구조를 유연하게 만든 핵심 변경이다.

### Chapter 23: 기존 동작을 건드리지 않았음을 어떻게 확인할 수 있을까? — "한 번에 하나만, 의식적으로"

이 챕터는 변경의 안전성을 높이는 다섯 가지 실천법을 소개한다. 이번 마이그레이션에 직접 적용된 것들:

**Single-Goal Editing (단일 목표 편집)**: 한 번에 하나의 목표만 추구한다. Phase 1에서는 Yarn만, Phase 2에서는 Node만 변경한다. 리팩토링 중 발견한 다른 문제(예: Node 업그레이드 중 발견한 코드 개선점)는 메모만 하고 현재 Phase가 끝난 후 처리한다. 목표를 섞으면 실수 확률이 급격히 증가한다.

**Lean on the Compiler (컴파일러에 기대기)**: TypeScript 4→5 업그레이드 시 타입 체커가 호환성 문제를 자동으로 잡아준다. Next.js 15의 async API 변경도 TypeScript가 "이 함수는 이제 Promise를 반환하니 await가 필요합니다"라고 알려주기 때문에, 20+ 파일을 수정할 때 누락 없이 처리할 수 있다.

**Preserve Signatures (시그니처 보존)**: 각 Phase에서 외부로 노출되는 API나 빌드 결과물의 시그니처는 변경하지 않는다. 내부 구현(런타임 버전, 빌드 도구)만 바꾸고 외부 동작은 동일하게 유지한다.

### Chapter 24: 어찌해야 할지 모르겠다. 나아질 것 같지 않아 — "한 번에 모든 것을 고치려 하지 마라"

이 챕터는 레거시 코드의 압도감에 대한 심리적, 실질적 대응을 다룬다. 핵심 메시지는 **점진적 개선**이다.

PC Next.js 15 보류 결정이 이 챕터의 원칙을 정확히 따른다:
- 160개 파일 수정, 3단계 메이저 점프(12→13→14→15)는 한 번에 하기엔 너무 크다
- 롤백이 어렵고, QA 부담이 크며, Pages Router에서 Next.js 15 핵심 기능 활용도 불가
- 대신 12.3.7 보안 패치(CVE-2025-29927 대응)만 적용하여 **즉각적인 위험을 제거**

이 챕터의 **보이스카우트 규칙**("코드를 발견했을 때보다 조금 더 깨끗하게 남겨라")도 적용되었다. 전체를 한번에 완벽하게 만들지 않더라도, 각 Phase를 거치며 코드베이스는 점점 더 건강한 상태로 이동한다.

### Chapter 2: 피드백 활용 — "Edit and Pray가 아니라 Cover and Modify"

이 챕터는 코드 변경의 두 가지 접근 방식을 대비한다:
- **Edit and Pray**: 신중하게 계획하고, 변경하고, 동작하는지 기도하는 방식
- **Cover and Modify**: 변경할 코드를 테스트로 덮고(cover), 테스트의 보호 아래 수정하는 방식

각 Phase마다 **PoC로 빌드/실행을 검증**하는 것이 Cover and Modify의 실제 구현이다. "QA 배포 완료 → 검증 → 프로덕션 배포" 흐름도 피드백 루프를 만드는 과정이다.

이 챕터가 특히 중요한 이유는 **레거시 코드의 딜레마**를 제시하기 때문이다: "코드를 변경하려면 테스트가 필요한데, 테스트를 넣으려면 코드를 변경해야 한다." 이번 마이그레이션에서 각 Phase를 매우 보수적이고 작은 단위로 나눈 것이 이 딜레마를 우회하는 전략이다.

---

## 보통 관련: 부분적으로 원칙이 적용된 챕터

### Chapter 4: 봉합 모델 — "코드를 편집하지 않고 동작을 바꿀 수 있는 지점"

이 챕터는 **Seam(봉합/이음새)** 이라는 핵심 개념을 소개한다. Seam이란 소스 코드를 직접 수정하지 않고도 프로그램의 동작을 바꿀 수 있는 지점이다. 그리고 **Enabling Point**는 해당 Seam에서 어떤 동작을 사용할지 결정하는 지점이다.

세 가지 Seam 유형 중 이번 작업과 관련 있는 것:

**Link Seam**: 링크(빌드) 단계에서 다른 구현체로 교체하는 방식. webpack alias를 사용하여 React 듀얼 인스턴스 문제를 해결한 것이 JavaScript 세계의 Link Seam이다. 코드를 수정하지 않고 webpack 설정(Enabling Point)에서 React의 resolve 경로를 지정하여 싱글톤을 보장했다.

**Object Seam**: 다형성을 이용한 의존성 교체. 앱별 React 버전 독립 관리로 전환한 것은, 각 앱이 자신의 `package.json`(Enabling Point)에서 사용할 React 버전을 독립적으로 결정할 수 있게 만든 것이다. TV는 19, PC는 18.3.1을 선택할 수 있는 유연성이 생겼다.

### Chapter 3: 감지와 분리 — "테스트를 위해 의존성을 끊는 두 가지 이유"

이 챕터는 의존성을 깨야 하는 두 가지 이유를 설명한다:
- **Sensing(감지)**: 코드가 수행하는 동작을 외부에서 확인할 수 없을 때
- **Separation(분리)**: 코드를 나머지 시스템으로부터 격리할 수 없을 때

React 듀얼 인스턴스 문제가 이 구조를 따른다:
1. **감지**: 모노레포에서 React가 두 벌 로드되는 것을 감지 (런타임 에러로 발견)
2. **분리**: webpack alias로 React를 하나의 인스턴스로 격리 (싱글톤 보장)

기존 루트 `resolutions` 강제 통일 구조도 Separation 문제였다. 모든 앱이 하나의 React 버전에 묶여 있어, 개별 앱을 독립적으로 테스트하거나 업그레이드할 수 없었다. 앱별 독립 관리로 전환하여 각 앱을 분리(Separation)한 것이다.

### Chapter 15: 애플리케이션에 API 호출이 너무 많다 — "API를 감싸서 추상화 계층을 만들라"

이 챕터는 API 호출이 코드 전체에 직접 퍼져 있을 때의 문제와 해결책을 다룬다. 핵심 전략은 **"Skin and Wrap the API"** — API를 얇은 래퍼로 감싸서 비즈니스 코드가 래퍼에만 의존하게 만드는 것이다.

Next.js 15에서 `cookies()`, `headers()`, `searchParams`, `params`가 비동기로 변경되었다:

```typescript
// Next.js 14 (동기)
const token = cookies().get('token');

// Next.js 15 (비동기)
const cookieStore = await cookies();
const token = cookieStore.get('token');
```

Account에서 서버 유틸 함수 8개 + 페이지 컴포넌트 20+개를 async로 변환해야 했다. 만약 `cookies()`를 직접 호출하는 대신 래퍼 함수(`getAuthToken()` 등)를 통해 사용하고 있었다면, 래퍼 함수 하나만 수정하면 되었을 것이다.

이는 향후 프레임워크 API 변경에 대비한 설계 교훈이기도 하다.

### Chapter 12: 클래스 의존 관계, 반드시 없애야 할까? — "영향이 모이는 좁은 지점을 찾아라"

이 챕터는 한 영역에서 여러 변경이 필요할 때, 모든 곳에 테스트를 넣는 대신 **Pinch Point(병목 지점)** 를 찾아 그곳에서 테스트하는 전략을 소개한다. Pinch Point란 여러 변경의 영향이 하나로 모이는 좁은 지점이다.

PC Next.js 15 보류 결정의 이론적 근거가 된다. 160개 파일 전체를 바꾸는 대신, 보안 취약점이라는 가장 좁은 Pinch Point에 집중하여 12.3.7 패치만 적용했다. 변경 파일은 ~10개로 최소화되고, 즉시 롤백 가능하며, Breaking Changes도 없다.

이 챕터의 **Pinch Point Trap** 경고도 관련이 있다: Pinch Point 테스트(여기서는 보안 패치만 적용하는 접근)에 너무 오래 의존하면 안 되며, 궁극적으로는 PC Next.js 15 마이그레이션을 별도 티켓으로 진행해야 한다.

### Chapter 6: 고칠 것은 많고 시간은 없고 — "기존 코드와 새 코드를 명확히 분리하라"

이 챕터는 시간 압박 속에서 안전하게 코드를 변경하는 네 가지 기법을 소개한다. 그중 **Sprout Class(발아 클래스)** 와 **Wrap Class(감싸기 클래스)** 가 이번 작업과 관련된다.

앱별 React 버전 독립 관리로 전환한 것이 Sprout 개념과 유사하다. 기존 구조(루트 resolutions 강제)를 직접 수정하는 대신, 각 앱의 `package.json`에서 독립적으로 React 버전을 관리하는 새로운 구조를 "발아"시켰다. 기존 코드를 건드리지 않으면서 새로운 관리 방식을 도입한 것이다.

이 챕터의 핵심 메시지인 **"지금 투자하지 않으면 나중에 더 큰 비용을 치른다"** 도 마이그레이션 전체의 동기와 일치한다. Node.js 18 EOL, Next.js 14 EOL을 방치하면 보안 패치가 중단되고, 나중에 한꺼번에 올려야 하는 비용은 기하급수적으로 증가한다.

---

## 약한 관련: 개념적으로 연결되는 챕터

### Chapter 5: 도구

CI/CD 워크플로우 25개 파일, Dockerfile 5개 파일을 변경한 것은 빌드/배포 도구의 중요성을 보여준다. 이 챕터에서 강조하는 "도구는 수단이지 목적이 아니다"라는 원칙이 적용된다. Yarn 4 업그레이드도 빌드 속도 개선이라는 실용적 목적을 위한 도구 변경이다.

### Chapter 8: 어떻게 기능을 추가할까?

이 챕터의 **Programming by Difference(차이에 의한 프로그래밍)** 개념이 PC의 React 18.3.1 유지 결정과 연결된다. Next.js 12 + React 19는 테스트되지 않은 비공식 조합이므로, 기존 동작과의 "차이"를 최소화하기 위해 18.3.1을 유지하는 보수적 선택을 했다.

### Chapter 20: 이 클래스는 너무 비대해서 더 이상 확장하고 싶지 않다

모노레포의 루트 `resolutions`로 모든 앱의 React 버전을 강제 통일하던 구조는, 하나의 설정이 너무 많은 책임을 지는 "God Class" 문제와 유사하다. 앱별 독립 관리로 전환한 것은 **Single Responsibility Principle(단일 책임 원칙)** 의 적용이다. 각 앱이 자신의 의존성을 스스로 관리한다.

### 부록: Refactoring

`node-sass → dart-sass` 전환은 부록에서 다루는 리팩토링 기법 중 **Replace Type Code with Subclasses** 의 라이브러리 버전에 해당한다. 동일한 인터페이스(Sass 컴파일)를 제공하는 다른 구현체(dart-sass)로 교체한 것이다.

---

## 정리: 관련도별 챕터 맵

### 깊은 관련 (핵심 원칙이 직접 적용)

| 챕터 | 핵심 연결 | 해당 작업 |
|------|----------|----------|
| Ch01 소프트웨어 변경 | 기존 동작 보존이 가장 어렵다 | 각 Phase에서 기능 동일 유지 |
| Ch07 왜 이리 오래 걸리지? | 독립적 변경 먼저 + 계층적 변경은 하위→상위 | Yarn/TS(독립), Node→React→Next.js(계층) |
| Ch14 라이브러리 의존 관계 | 라이브러리를 감싸라 | node-sass→dart-sass, 앱별 독립 관리 |
| Ch23 기존 동작 확인 | 한 번에 하나만, 컴파일러 활용 | Phase별 단일 목표, TS 타입 체크 |
| Ch24 어찌해야 할지 모르겠다 | 점진적 개선, 보이스카우트 규칙 | PC Next.js 15 보류, Phase별 진행 |
| Ch02 피드백 활용 | Cover and Modify | Phase별 PoC 빌드/실행 검증 |

### 보통 관련 (부분적으로 원칙 적용)

| 챕터 | 핵심 연결 | 해당 작업 |
|------|----------|----------|
| Ch04 봉합 모델 | Seam과 Enabling Point | webpack alias, 앱별 버전 선택 |
| Ch03 감지와 분리 | Sensing과 Separation | React 듀얼 인스턴스 감지/해결 |
| Ch15 API 호출이 너무 많다 | API를 래핑하라 | Next.js 15 async API 변경 대응 |
| Ch12 한 영역 다수 변경 | Pinch Point 찾기 | PC 12.3.7 패치만 적용 |
| Ch06 시간은 없고 | 기존/새 코드 분리, 나중에 더 비싸다 | 앱별 독립 관리, EOL 대응 |

### 약한 관련 (개념적 연결)

| 챕터 | 핵심 연결 | 해당 작업 |
|------|----------|----------|
| Ch05 도구 | 도구는 수단이지 목적이 아니다 | CI/CD, Dockerfile 변경 |
| Ch08 기능 추가 | 차이를 최소화하는 보수적 선택 | PC React 18.3.1 유지 |
| Ch20 비대한 클래스 | 단일 책임 원칙 | 루트 resolutions → 앱별 관리 |
| 부록 리팩토링 | 동일 인터페이스의 구현체 교체 | node-sass → dart-sass |
