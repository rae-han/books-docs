# Chapter 23: 기존 동작을 건드리지 않았음을 어떻게 확인할 수 있을까? (How Do I Know That I'm Not Breaking Anything?)

## 핵심 질문

레거시 코드를 변경할 때, 기존 동작을 깨뜨리지 않았다는 것을 어떻게 확신할 수 있는가? 테스트가 부족하거나 없는 상황에서, 변경의 안전성을 높이기 위해 어떤 실천법을 적용할 수 있는가?

---

## 1. 변경의 두려움

레거시 코드를 다루는 개발자들이 가장 자주 느끼는 감정은 **두려움**이다. 코드를 변경할 때마다 "이 변경이 다른 곳을 깨뜨리지 않았을까?" 하는 불안감이 따라온다. 이 두려움은 근거 없는 것이 아니다. 레거시 코드는 테스트가 없기 때문에, 변경 후 기존 동작이 보존되었는지 확인할 방법이 마땅치 않다.

하지만 테스트가 부족하다고 해서 아무것도 할 수 없는 것은 아니다. Feathers는 이 장에서 **테스트 외에도 변경의 안전성을 높이는 다섯 가지 실천법**을 제시한다:

1. **Hyperaware Editing** (초의식적 편집)
2. **Single-Goal Editing** (단일 목표 편집)
3. **Preserve Signatures** (시그니처 보존)
4. **Lean on the Compiler** (컴파일러에 기대기)
5. **Pair Programming** (짝 프로그래밍)

이 기법들은 테스트를 대체하는 것이 아니라, **테스트가 부족한 상황에서 실수를 줄이기 위한 보완 수단**이다.

---

## 2. Hyperaware Editing (초의식적 편집)

### 2.1 개념

Hyperaware Editing은 **코드를 변경하는 모든 순간에 각 줄이 무엇을 하는지 정확히 이해하면서 편집하는 태도**이다. 코드의 한 줄을 수정할 때, 그 줄이 미치는 모든 영향을 의식적으로 추적한다.

### 2.2 무의식적 편집과의 대비

대부분의 개발자는 코드를 편집할 때 **무의식적(unconscious)** 으로 작업한다:

| 무의식적 편집 | 초의식적 편집 |
|-------------|-------------|
| 코드를 빠르게 수정하고 "아마 될 것이다"라고 생각 | 각 줄의 영향을 명확히 이해한 후 수정 |
| 변경 후 바로 다음 작업으로 넘어감 | 변경 후 주변 코드에 미치는 영향을 확인 |
| 실수를 나중에 테스트/디버깅에서 발견 | 실수를 편집 시점에서 방지 |
| "이렇게 하면 되겠지" 느낌으로 진행 | "이 변경이 정확히 이런 영향을 미친다"고 논리적으로 확인 |

### 2.3 실천 방법

**변수 변경 시:**
```java
// 이 변수를 변경하면...
double total = subtotal + tax;
// 질문: total을 사용하는 모든 곳은 어디인가?
// 질문: subtotal이나 tax가 이 시점에서 올바른 값을 갖고 있는가?
// 질문: total의 타입이 double인 이유가 있는가? 정밀도 문제는 없는가?
```

**조건문 변경 시:**
```java
// 이 조건을 바꾸면...
if (account.getBalance() > 0) {
// 질문: 경계값(0)인 경우는 어떻게 되는가?
// 질문: account가 null일 가능성은 없는가?
// 질문: 이 조건의 else 분기에서 무슨 일이 일어나는가?
```

**메서드 호출 변경 시:**
```java
// 이 호출을 추가/변경하면...
processor.execute(order);
// 질문: execute()에 부수 효과(side effect)가 있는가?
// 질문: order의 상태가 이 호출 후 변경되는가?
// 질문: 예외가 발생할 가능성은? 어디서 잡히는가?
```

### 2.4 핵심: 속도를 늦추되 정확성을 높이기

> Hyperaware Editing은 느리게 작업하는 것이 아니다. **의식적으로** 작업하는 것이다. 무의식적으로 빠르게 편집하고 디버깅에 오래 걸리는 것보다, 의식적으로 편집하고 한 번에 올바르게 만드는 것이 결과적으로 더 빠르다.

레거시 코드에서는 코드의 맥락을 이해하기 어렵기 때문에, 의식적 편집이 특히 중요하다. 코드가 "왜" 그렇게 작성되었는지 모르는 상태에서 변경하면, 의도하지 않은 결과를 초래할 가능성이 높다.

### 2.5 Hyperaware Editing을 기르는 방법

- **연습**: 의식적으로 노력해야 습관이 된다. 처음에는 의식적으로 속도를 늦추고, 각 변경의 영향을 추적하는 연습을 한다.
- **테스트 작성**: 테스트를 작성하면서 코드를 이해하는 과정이 Hyperaware Editing 능력을 향상시킨다.
- **코드 읽기**: 변경하기 전에 주변 코드를 충분히 읽는다.

---

## 3. Single-Goal Editing (단일 목표 편집)

### 3.1 개념

Single-Goal Editing은 **한 번에 하나의 목표만 추구하며 코드를 편집하는 원칙**이다. 리팩토링 중 발견한 다른 문제는 메모만 하고 나중에 별도로 처리한다.

### 3.2 왜 목표를 섞으면 안 되는가

코드를 변경하다 보면, 관련된 다른 문제들이 눈에 들어오기 마련이다:

```
리팩토링 중에...
├── "이 변수 이름이 좀 이상하네, 바꿔야겠다"
├── "이 메서드도 너무 긴데, 여기도 리팩토링해야지"
├── "이 클래스에 null 체크가 없네, 추가해야겠다"
└── "이 부분은 성능이 좀 걱정되는데..."
```

이런 유혹에 빠져 여러 가지를 동시에 변경하면:

1. **실수 확률이 급격히 증가**한다. 한 번에 하나의 변경만 할 때보다, 여러 변경을 동시에 할 때 실수할 가능성이 기하급수적으로 높아진다.
2. **문제 발생 시 원인 파악이 어렵다**. 무언가 깨졌을 때, 어떤 변경이 원인인지 알 수 없다.
3. **되돌리기(undo)가 어렵다**. 여러 변경이 섞여 있으면 특정 변경만 선택적으로 되돌릴 수 없다.

### 3.3 실천 방법

```
[올바른 접근]
1. 목표를 하나 설정한다: "메서드 A를 Extract Method로 분리한다"
2. 그 목표만 수행한다.
3. 컴파일/테스트로 확인한다.
4. 완료되면 다음 목표를 설정한다.

[잘못된 접근]
1. 메서드 A를 분리하면서...
2. 변수 이름도 바꾸고...
3. 불필요한 코드도 정리하고...
4. 새 기능도 추가하고...
5. → 무언가 깨짐 → 어디서 잘못된 건지 모름
```

### 3.4 메모 활용

리팩토링 중 발견한 다른 문제는 **메모(scratch pad)에 기록**한다:

```
TODO:
- [ ] calculateTotal()의 변수명 정리 필요
- [ ] processOrder()의 null 체크 추가
- [ ] ShippingCalculator 클래스 리팩토링 필요
```

> 리팩토링 중에 다른 문제를 발견했다면, 그것은 좋은 일이다. 하지만 지금 하고 있는 작업을 멈추고 그 문제를 해결하려고 하면 안 된다. 메모하고 나중에 처리하라.

### 3.5 프로그래밍의 두 가지 모자

Kent Beck은 프로그래밍에서 **두 가지 모자(hat)** 를 구분한다:

1. **리팩토링 모자**: 동작을 변경하지 않으면서 구조를 개선
2. **기능 추가 모자**: 새로운 동작을 추가

Single-Goal Editing의 핵심은 **한 번에 하나의 모자만 쓰는 것**이다. 리팩토링 중에 기능을 추가하거나, 기능 추가 중에 리팩토링을 하면 실수가 발생한다.

---

## 4. Preserve Signatures (시그니처 보존)

### 4.1 개념

Preserve Signatures는 **리팩토링 시 메서드의 시그니처(매개변수의 이름, 타입, 순서)를 최대한 그대로 유지하는 원칙**이다. 시그니처를 변경하지 않으면, 실수할 가능성이 크게 줄어든다.

### 4.2 시그니처 변경이 위험한 이유

메서드를 추출하거나 이동할 때, 매개변수를 다루는 과정에서 흔히 발생하는 실수:

```java
// 원래 코드
void process(String name, int count, double rate) {
    // ...
}

// 추출하면서 매개변수 순서를 바꿈 (실수!)
void extracted(int count, String name, double rate) {  // count와 name 순서가 바뀜
    // ...
}

// 호출 시
extracted(name, count, rate);  // 타입이 다르면 컴파일 에러, 같으면 무음 버그!
```

특히 **같은 타입의 매개변수가 여러 개**인 경우 순서가 바뀌어도 컴파일러가 잡지 못한다:

```java
void transfer(String fromAccount, String toAccount, double amount) {
    // ...
}

// 실수로 순서를 바꿔 호출하면 → 컴파일은 되지만 동작이 완전히 잘못됨
transfer(toAccount, fromAccount, amount);
```

### 4.3 실천 방법

**Copy/Paste를 활용한 안전한 시그니처 이동:**

Extract Method를 수동으로 수행할 때, 매개변수를 직접 타이핑하지 말고 **원래 코드에서 Copy/Paste**하여 옮긴다.

```java
// 원래 메서드
void processPayment(String accountId, double amount, Currency currency) {
    // 이 부분을 추출하려 한다
    double converted = converter.convert(amount, currency, Currency.USD);
    gateway.charge(accountId, converted);
}

// 새 메서드: 매개변수를 원래 코드에서 Copy/Paste
//                     ↓ 복사            ↓ 복사        ↓ 복사
void chargeInUSD(String accountId, double amount, Currency currency) {
    double converted = converter.convert(amount, currency, Currency.USD);
    gateway.charge(accountId, converted);
}
```

이렇게 하면 매개변수의 이름, 타입, 순서가 **기계적으로 보존**된다.

### 4.4 매개변수 이름 유지의 중요성

매개변수 이름을 바꾸고 싶은 유혹이 있더라도, **리팩토링 단계에서는 이름을 그대로 유지**한다. 이름 변경은 별도의 단계에서 수행한다. 이것은 Single-Goal Editing 원칙과도 일치한다.

```java
// 리팩토링 단계: 이름 그대로 유지
void calculateShipping(String addr, int qty) {
    // addr이라는 이름이 마음에 안 들지만, 지금은 바꾸지 않는다
}

// 별도의 단계에서 이름 변경
void calculateShipping(String address, int quantity) {
    // 이제 이름을 바꾼다 (이것이 유일한 변경)
}
```

### 4.5 시그니처 보존이 특히 중요한 경우

- **Extract Method**: 추출된 메서드의 매개변수가 원래 변수와 정확히 일치해야 한다.
- **Move Method**: 메서드를 다른 클래스로 이동할 때 시그니처를 유지한다.
- **Pull Up / Push Down**: 상속 계층에서 메서드를 이동할 때 시그니처를 유지한다.

---

## 5. Lean on the Compiler (컴파일러에 기대기)

### 5.1 개념

Lean on the Compiler는 **의도적으로 컴파일 에러를 발생시켜, 변경이 필요한 모든 지점을 컴파일러가 찾아주게 하는 기법**이다. 정적 타입 언어(Java, C++, C# 등)에서 매우 효과적이다.

### 5.2 기본 원리

컴파일러는 코드의 모든 참조를 알고 있다. 무언가를 의도적으로 깨뜨리면, 컴파일러가 깨진 모든 지점을 에러로 보고해준다. 이를 활용하여 **변경이 미치는 영향 범위를 정확히 파악**할 수 있다.

### 5.3 활용 시나리오

**시나리오 1: 메서드를 사용하는 모든 곳 찾기**

특정 메서드를 변경하거나 제거하려 할 때, 그 메서드를 사용하는 모든 코드를 찾아야 한다:

```java
// 원래 메서드
public void processOrder(Order order) {
    // ...
}

// 1단계: 의도적으로 메서드 이름을 변경
public void processOrder_FINDING_REFERENCES(Order order) {
    // ...
}

// 2단계: 컴파일 → 모든 호출 지점에서 에러 발생
// Error: cannot find symbol: method processOrder(Order)
//   at OrderController.java:45
//   at BatchProcessor.java:123
//   at OrderTest.java:67
//   ...

// 3단계: 모든 참조를 확인한 후, 이름을 원래대로 복원
```

**시나리오 2: 타입 변경으로 영향 범위 파악**

```java
// 원래 코드
public class Account {
    private double balance;

    public double getBalance() {
        return balance;
    }
}

// 1단계: 반환 타입을 의도적으로 변경
public int getBalance() {  // double → int로 변경
    return (int) balance;
}

// 2단계: 컴파일 → getBalance()의 반환값을 double로 받는 모든 곳에서 에러
// 이를 통해 balance가 사용되는 모든 맥락을 파악할 수 있다

// 3단계: 파악 후 타입을 원래대로 복원
```

**시나리오 3: 매개변수 추가로 호출 지점 파악**

```java
// 원래 메서드
public void send(Message message) {
    // ...
}

// 1단계: 매개변수를 추가
public void send(Message message, boolean dummy) {  // dummy 매개변수 추가
    // ...
}

// 2단계: 컴파일 → send(Message)로 호출하는 모든 곳에서 에러
// 이를 통해 모든 호출 지점을 파악

// 3단계: 파악 후 dummy 매개변수 제거
```

### 5.4 주의사항

- **동적 타입 언어에서는 사용할 수 없다.** Python, Ruby, JavaScript 등에서는 컴파일러가 없으므로 이 기법을 적용할 수 없다.
- **리플렉션(reflection)으로 호출되는 코드**는 컴파일러가 잡지 못한다.
- **오버로딩(overloading)** 이 있는 경우, 매개변수 변경이 다른 오버로드 버전으로 연결될 수 있으므로 주의해야 한다.
- 이 기법은 **탐색용**이다. 영향 범위를 파악한 후에는 반드시 원래 상태로 복원해야 한다.

> Lean on the Compiler는 컴파일러를 "검색 도구"로 사용하는 것이다. IDE의 "Find All References" 기능과 유사하지만, 컴파일러는 더 정확하고 빠짐없이 찾아준다.

### 5.5 Lean on the Compiler와 IDE 도구의 비교

| 방법 | 장점 | 단점 |
|------|------|------|
| **Lean on the Compiler** | 모든 참조를 빠짐없이 찾음, 오버로딩 등 미묘한 문제도 감지 | 의도적으로 코드를 깨뜨려야 함, 원래 상태로 복원 필요 |
| **IDE Find References** | 코드를 수정하지 않아도 됨, 빠름 | 간접 참조, 리플렉션 등을 놓칠 수 있음 |

가능하다면 두 방법을 **함께 사용**하는 것이 가장 안전하다.

---

## 6. Pair Programming (짝 프로그래밍)

### 6.1 개념

Pair Programming은 **두 사람이 하나의 컴퓨터 앞에서 함께 코드를 작성하는 실천법**이다. 한 사람(driver)이 코드를 타이핑하고, 다른 사람(navigator)이 전략적 관점에서 코드를 검토한다.

### 6.2 레거시 코드에서 짝 프로그래밍이 특히 유용한 이유

레거시 코드 작업은 일반적인 개발보다 **실수의 위험이 훨씬 높다**:

1. **코드의 의도를 모르는 상태**에서 변경해야 하므로, 두 사람의 눈이 실수를 잡을 확률이 높다.
2. **테스트가 없는 상태**에서 변경하므로, 사람의 주의력이 유일한 안전망인 경우가 많다.
3. **복잡한 코드**를 이해해야 하므로, 두 사람이 함께 논의하면 이해가 빨라진다.
4. 한 사람이 **Hyperaware Editing**에 집중하는 동안, 다른 사람이 **전체적인 맥락**을 모니터링할 수 있다.

### 6.3 레거시 코드에서의 짝 프로그래밍 패턴

**패턴 1: Navigator가 영향 범위를 추적**

```
Driver: processOrder() 메서드에서 이 줄을 변경합니다.
Navigator: 잠깐, 그 변수는 아래 checkInventory()에서도 사용되고 있어요.
           거기도 확인해야 합니다.
```

**패턴 2: Driver가 편집, Navigator가 테스트 계획**

```
Driver: Extract Method를 수행합니다.
Navigator: 추출 후에 이 시나리오들을 테스트해야 합니다:
           1. 입력이 빈 리스트인 경우
           2. null 항목이 포함된 경우
           3. ...
```

**패턴 3: 교대로 역할 변경**

리팩토링의 각 단계마다 역할을 교대하면, 두 사람 모두 코드에 대한 깊은 이해를 유지할 수 있다.

### 6.4 짝 프로그래밍의 효과

- **실시간 코드 리뷰**: 코드가 작성되는 순간에 리뷰가 이루어진다.
- **지식 공유**: 레거시 코드에 대한 이해가 한 사람에게 집중되는 것을 방지한다.
- **집중력 유지**: 혼자 작업하면 주의가 분산되기 쉽지만, 둘이 함께하면 집중력을 유지하기 쉽다.
- **자신감 향상**: 레거시 코드 변경에 대한 두려움이 줄어든다.

---

## 7. 다섯 가지 기법의 통합 적용

이 장에서 소개한 다섯 가지 기법은 독립적으로 사용할 수도 있지만, **함께 사용할 때 가장 효과적**이다.

### 7.1 통합 적용 시나리오

레거시 코드에서 메서드를 추출해야 하는 상황을 가정한다:

```
1. [Pair Programming] 동료와 함께 작업을 시작한다.
2. [Single-Goal Editing] 목표를 하나 설정한다: "calculateTax 부분을 메서드로 추출한다."
3. [Lean on the Compiler] 관련 변수의 타입을 임시로 변경하여 영향 범위를 파악한다.
4. [Preserve Signatures] Copy/Paste로 매개변수를 정확히 보존하며 메서드를 추출한다.
5. [Hyperaware Editing] 추출 과정의 각 단계에서 변경의 영향을 의식적으로 확인한다.
6. 컴파일하고 테스트(있다면)를 실행한다.
7. 목표 완료 후 다음 목표를 설정한다.
```

### 7.2 각 기법의 보완 관계

| 기법 | 방지하는 실수 유형 |
|------|------------------|
| Hyperaware Editing | 각 줄의 영향을 이해하지 못한 채 변경하는 실수 |
| Single-Goal Editing | 여러 변경을 동시에 수행하면서 생기는 혼란 |
| Preserve Signatures | 매개변수 이름, 타입, 순서를 잘못 옮기는 실수 |
| Lean on the Compiler | 변경의 영향 범위를 파악하지 못하는 실수 |
| Pair Programming | 혼자서는 놓치기 쉬운 모든 종류의 실수 |

---

## 8. 테스트와의 관계

이 장의 기법들은 **테스트를 대체하지 않는다**. Feathers는 이 점을 분명히 한다:

> 이 기법들은 테스트가 없을 때의 차선책이다. 궁극적인 목표는 여전히 테스트를 작성하는 것이다. 하지만 테스트가 없는 현실에서, 이 기법들이 실수를 줄여줄 수 있다.

이 기법들의 위치는 다음과 같다:

```
[안전성 스펙트럼]

가장 안전                                                가장 위험
    |                                                      |
    자동화 테스트    이 장의 기법들    아무 보호 없이 변경
    + 이 기법들     (테스트 없이)
```

이상적으로는 테스트와 이 기법들을 **함께 사용**하는 것이 최선이다. 하지만 테스트가 없는 상황에서는, 이 기법들만이라도 적용하는 것이 아무것도 하지 않는 것보다 **훨씬 낫다**.

---

## 요약

- **Hyperaware Editing**: 변경하는 모든 줄의 의미와 영향을 정확히 이해하며 편집한다. 무의식적 편집과 대비되는 의식적 편집 태도이다.
- **Single-Goal Editing**: 한 번에 하나의 목표만 추구한다. 리팩토링 중 발견한 다른 문제는 메모만 하고 나중에 처리한다. 목표를 섞으면 실수 확률이 급격히 증가한다.
- **Preserve Signatures**: 메서드 시그니처(매개변수 이름, 타입, 순서)를 최대한 유지한다. Copy/Paste를 활용하여 시그니처를 정확하게 이동한다.
- **Lean on the Compiler**: 의도적으로 컴파일 에러를 발생시켜 변경이 필요한 모든 지점을 컴파일러가 찾아주게 한다. 정적 타입 언어에서 강력한 탐색 도구이다.
- **Pair Programming**: 두 사람이 함께 코드를 변경하면 실수를 잡을 확률이 높아진다. 레거시 코드 작업에서 특히 유용하다.
- 이 기법들은 테스트를 대체하지 않지만, 테스트가 없는 상황에서 **변경의 안전성을 의미 있게 높여준다**.

---

## 다음 챕터와의 연결

Chapter 24 **"어찌해야 할지 모르겠다. 나아질 것 같지 않아 (We Feel Overwhelmed. It Isn't Going to Get Any Better)"** 에서는 레거시 코드의 압도감에 직면한 팀이 어떻게 심리적으로, 그리고 실질적으로 대응할 수 있는지, 점진적 개선의 철학과 팀 문화에 대해 논의한다.
