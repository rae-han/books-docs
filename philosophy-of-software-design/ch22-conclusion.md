# Chapter 22: Conclusion (결론)

## 이 책의 중심 명제

> **소프트웨어 설계의 가장 근본적인 문제는 복잡성이다. 소프트웨어 설계의 목표는 복잡성을 최소화하는 것이다.**

복잡성은 시스템을 이해하고 수정하기 어렵게 만드는 모든 것이다. 복잡성은 한 번의 큰 실수가 아니라 수백 번의 작은 타협에서 축적된다. 따라서 모든 코드 변경에서 복잡성을 의식하고, 조금이라도 줄이려는 노력이 필요하다.

---

## 설계 원칙 종합 정리

### 복잡성의 본질
1. **복잡성은 증분적으로 축적된다** — 작은 복잡성들이 쌓여 시스템을 압도한다
2. **복잡성의 세 증상**: 변경 증폭, 인지 부하, Unknown Unknowns
3. **복잡성의 두 원인**: 의존성과 모호성

### 프로그래밍 철학
4. **동작하는 코드만으로는 부족하다** — 전술적이 아닌 전략적으로 프로그래밍하라
5. **설계에 10~20% 투자하라** — 이 투자는 수개월 내에 회수된다
6. **지속적으로 설계를 개선하라** — 매 변경이 설계를 개선하는 기회다

### 모듈 설계
7. **모듈은 깊어야 한다** — 단순한 인터페이스, 강력한 기능
8. **정보를 숨겨라** — 설계 결정을 모듈 내부에 가두어라
9. **범용 인터페이스를 만들어라** — 기능은 현재에, 인터페이스는 미래에 맞춰라
10. **계층이 다르면 추상화도 달라야 한다** — 통과 메서드를 피하라
11. **복잡성을 아래로 끌어내려라** — 인터페이스가 단순한 것이 구현이 단순한 것보다 중요하다
12. **합칠지 분리할지 판단하라** — 전체 복잡성이 줄어드는 방향을 선택
13. **에러를 정의 밖으로 내보내라** — 예외가 발생할 수 없도록 API를 재정의
14. **두 번 설계하라** — 대안을 비교하면 더 나은 설계를 얻는다

### 주석과 이름
15. **주석은 코드에 없는 정보를 전달해야 한다** — 코드를 반복하지 마라
16. **주석을 먼저 작성하라** — 주석은 설계 도구다
17. **이름은 정확하고 일관되게** — 모호한 이름은 복잡성을 높인다

### 실무 원칙
18. **기존 코드를 수정할 때도 전략적으로** — 캠핑 규칙을 지켜라
19. **일관성을 유지하라** — 한 패턴을 배우면 모든 곳에 적용 가능하도록
20. **코드는 명확해야 한다** — 독자의 첫 추측이 맞도록 작성하라
21. **트렌드를 복잡성 렌즈로 평가하라** — 무조건 좋은 트렌드는 없다
22. **설계 단계에서 성능을 고려하라** — 측정 먼저, 최적화 나중
23. **중요한 것을 결정하라** — 중요한 것은 강조하고, 나머지는 숨겨라

---

## Red Flags 전체 목록

아래 Red Flag 중 하나라도 해당되면 설계를 재검토해야 한다:

| Red Flag | 의미 | 관련 챕터 |
|----------|------|----------|
| **Shallow Module** | 인터페이스가 복잡한데 기능이 적음 | Ch 4 |
| **Information Leakage** | 같은 설계 결정이 여러 모듈에 분산 | Ch 5 |
| **Temporal Decomposition** | 실행 순서 기준으로 모듈을 나누어 정보 분산 | Ch 5 |
| **Overexposure** | 드물게 사용되는 기능이 일반 API에 노출 | Ch 5 |
| **Pass-Through Method** | 아무 기능 없이 다른 메서드를 호출만 함 | Ch 7 |
| **Repetition** | 같은 코드 패턴이 반복됨 | Ch 9 |
| **Special-General Mixture** | 범용 메커니즘에 특수 목적 코드가 섞임 | Ch 9 |
| **Conjoined Methods** | 한 메서드를 이해하려면 다른 메서드도 읽어야 함 | Ch 9 |
| **Comment Repeats Code** | 주석이 코드를 그대로 반복 | Ch 13 |
| **Vague Name** | 이름이 너무 넓어서 여러 의미로 해석 가능 | Ch 14 |
| **Hard to Pick Name** | 간단한 이름을 찾기 어려움 → 설계 문제 | Ch 14 |
| **Hard to Describe** | 주석으로 간단히 설명하기 어려움 → 추상화 문제 | Ch 15 |
| **Nonobvious Code** | 빠르게 읽어도 동작을 이해할 수 없음 | Ch 18 |

---

## 설계 능력의 발전

Ousterhout는 설계 능력이 **연습과 성찰**을 통해 발전한다고 강조한다:

- **코드를 작성할 때**: 매번 설계에 대해 생각하라. "더 단순하게 할 수 있을까?"
- **코드 리뷰에서**: 자신의 코드에 대한 피드백을 받고, 다른 사람의 코드에서 배워라
- **복잡성을 발견하면**: 멈추고, 왜 복잡한지 분석하고, 어떻게 개선할 수 있는지 생각하라
- **Red Flag를 활용하라**: 코드에서 Red Flag를 발견하면 설계를 재검토하라

---

## 마무리

> **"The reward for being a good designer is that you get to spend a larger fraction of your time in a zone of flow, where programming feels easy and productive."**

좋은 설계자가 되면, 프로그래밍이 쉽고 생산적으로 느껴지는 **몰입(flow)** 의 시간이 늘어난다. 깔끔한 코드베이스 위에서 작업하는 것은 즐겁다. 복잡한 코드베이스와 씨름하는 것은 고통스럽다.

좋은 설계는 단지 기술적 우수성의 문제가 아니라, **개발자로서의 삶의 질**에 직결된다.

---

## 이 책을 활용하는 방법

1. **코딩 시**: 매 설계 결정에서 "복잡성을 줄이는가?"를 자문
2. **코드 리뷰 시**: Red Flag 목록을 체크리스트로 활용
3. **설계 토론 시**: 이 책의 원칙을 공유 어휘로 사용 ("이건 얕은 모듈이야", "정보 누출이 있어")
4. **학습 시**: 다른 사람의 코드에서 깊은 모듈과 얕은 모듈을 찾아보기
5. **회고 시**: 자신이 작성한 코드에서 Red Flag를 찾고 개선
