# Chapter 15: Write The Comments First (주석을 먼저 작성하라)

## 핵심 질문

주석을 코드 이후가 아니라 이전에 작성하면 어떤 이점이 있는가? 주석이 어떻게 설계 도구로 작동하는가?

---

## 1. 늦은 주석은 나쁜 주석이다

대부분의 개발자는 코드를 먼저 쓰고, 주석은 나중에 (혹은 영원히 안) 쓴다.

나중에 쓴 주석의 문제:
- 설계 의도를 이미 잊었을 수 있다
- "코드가 이미 완성되었으니 빨리 끝내자"는 심리로 대충 작성하게 된다
- 주석이 귀찮은 **의무**로 느껴진다

---

## 2. 주석을 먼저 쓰는 과정

Ousterhout가 제안하는 과정:

### Step 1: 클래스 수준 주석 작성

```java
/**
 * LRU 정책을 사용하는 인메모리 캐시.
 *
 * 키-값 쌍을 저장하며, 용량 초과 시 가장 오래 접근되지 않은
 * 항목을 자동으로 제거한다. 스레드 안전하다.
 */
public class LruCache<K, V> {
    // 아직 구현 없음
}
```

이 단계에서 **클래스의 추상화가 명확한지** 확인한다. 설명이 길고 복잡해진다면 클래스의 책임이 과도하다는 신호다.

### Step 2: 주요 공개 메서드의 인터페이스 주석 작성

```java
/**
 * 키에 해당하는 값을 반환한다.
 *
 * @param key 조회할 키 (null 불가)
 * @return 키에 해당하는 값. 없으면 null.
 *         조회된 항목은 "가장 최근 접근"으로 갱신된다.
 */
public V get(K key) {
    // 아직 구현 없음
}

/**
 * 키-값 쌍을 캐시에 저장한다.
 *
 * 이미 같은 키가 있으면 값을 덮어쓴다.
 * 캐시가 가득 차면 가장 오래된 항목을 제거한 후 저장한다.
 *
 * @param key 키 (null 불가)
 * @param value 값 (null 불가)
 */
public void put(K key, V value) {
    // 아직 구현 없음
}
```

### Step 3: 주요 인스턴스 변수 주석 작성

```java
/** 키에서 노드로의 매핑. O(1) 조회를 위해 HashMap 사용. */
private Map<K, Node<K, V>> map;

/** LRU 순서를 유지하는 이중 연결 리스트의 head (가장 최근 접근). */
private Node<K, V> head;

/** LRU 순서를 유지하는 이중 연결 리스트의 tail (가장 오래된 접근). */
private Node<K, V> tail;

/** 캐시의 최대 항목 수. 0보다 커야 한다. */
private int capacity;
```

### Step 4: 코드 작성 (구현 주석을 함께)

```java
public V get(K key) {
    Node<K, V> node = map.get(key);
    if (node == null) return null;

    // 접근된 노드를 리스트의 head로 이동 (LRU 갱신)
    moveToHead(node);
    return node.value;
}
```

---

## 3. 주석이 설계 도구인 이유

### 3.1 주석이 설계 문제를 드러낸다

주석을 작성하면서 **설계 문제가 조기에 발견**된다:

- 클래스 주석이 길고 복잡하다 → 클래스의 **책임이 과도**하다
- 메서드 주석에서 예외 조건이 너무 많다 → **인터페이스가 복잡**하다
- 동작을 설명하기 어렵다 → **추상화가 깔끔하지 않다**
- 여러 관련 없는 것을 설명해야 한다 → **관심사가 분리되지 않았다**

> **핵심 통찰**: "주석을 쓰기 어려운 것은 설계가 잘못되었다는 신호다." 주석은 설계의 **리트머스 시험지**다.

### 3.2 피드백 루프

```
주석 작성 → 설계 평가 → 설계 개선 → 주석 수정 → 코드 작성
```

이 순서로 하면 코드를 작성하기 **전에** 설계 문제를 발견하고 수정할 수 있다. 코드를 먼저 쓰면 설계를 바꾸는 비용이 커진다.

---

## 4. 설계 위험을 줄인다

| 접근 | 설계 문제 발견 시점 | 수정 비용 |
|------|-------------------|----------|
| 주석 먼저 | 코드 작성 **전** | 낮음 (주석만 수정) |
| 주석 나중 | 코드 작성 **후** | 높음 (코드 전체 수정 가능) |
| 주석 안 씀 | 코드 리뷰 또는 프로덕션 | 매우 높음 |

---

## 5. 주석 먼저 쓰기는 즐겁다

심리적 차이:

- **코드 → 주석**: 주석이 지루한 **사후 작업**으로 느껴진다. "이미 끝났는데 왜 또..."
- **주석 → 코드**: 주석이 창의적인 **설계 과정**의 일부로 느껴진다. "이 모듈을 어떻게 만들까?"

Ousterhout는 주석을 먼저 쓰면 주석 작성에 대한 **태도 자체가 바뀐다**고 강조한다.

---

## 요약

- **코드보다 주석을 먼저 작성하라**: 클래스 주석 → 메서드 주석 → 변수 주석 → 코드.
- 주석을 먼저 쓰면 **설계 문제를 조기에** 발견할 수 있다.
- 주석이 길거나 복잡하면 **설계가 잘못되었다는 신호**다.
- 주석 먼저 쓰기는 **설계 위험을 줄인다**: 코드 작성 전에 문제를 수정하므로 비용이 낮다.
- 주석을 나중에 쓰면 귀찮은 의무가 되지만, 먼저 쓰면 **창의적 설계 과정**이 된다.

---

## 다음 챕터와의 연결

Chapter 16 **"Modifying Existing Code (기존 코드 수정하기)"** 에서는 기존 코드를 수정할 때 설계를 유지하고 개선하는 방법을 다룬다. 코드를 수정할 때 주석도 함께 업데이트하는 것이 핵심이다.
