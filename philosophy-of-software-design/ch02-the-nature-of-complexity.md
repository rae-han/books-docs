# Chapter 2: The Nature of Complexity (복잡성의 본질)

## 핵심 질문

복잡성이란 정확히 무엇인가? 어떻게 인식할 수 있으며, 무엇이 복잡성을 유발하는가?

---

## 1. 복잡성의 정의

### 1.1 Ousterhout의 정의

Ousterhout는 복잡성을 다음과 같이 정의한다:

> **Complexity is anything related to the structure of a software system that makes it hard to understand and modify the system.**

> 복잡성이란 소프트웨어 시스템의 구조에서 시스템을 **이해하고 수정하기 어렵게 만드는 모든 것**이다.

이 정의에서 주목할 점:

- **"구조"에 관한 것이다**: 복잡성은 코드의 기능이 아니라 구조의 문제다. 같은 기능을 복잡하게 구현할 수도, 단순하게 구현할 수도 있다.
- **"이해하고 수정하기"에 초점을 맞춘다**: 복잡성은 **개발자의 경험**으로 정의된다. 시스템이 아무리 정교해도 이해하고 수정하기 쉽다면 복잡하지 않다.
- **절대적이 아니라 상대적이다**: 동일한 코드도 경험 많은 개발자에게는 단순할 수 있고, 새로운 개발자에게는 복잡할 수 있다. 하지만 좋은 설계는 경험에 관계없이 이해하기 쉬운 구조를 만든다.

### 1.2 실용적 관점에서의 복잡성

Ousterhout는 이론적 정의 외에 실용적인 관점도 제시한다:

> 복잡성은 **단순한 작업을 완료하는 데 드는 노력**으로 측정할 수 있다.

시스템이 복잡하면:
- 작은 개선이나 버그 수정에도 많은 시간이 필요하다
- 변경을 위해 많은 코드를 읽어야 한다
- 변경의 영향 범위를 파악하기 어렵다

시스템이 단순하면:
- 변경 사항이 명확하고 국지적이다
- 적은 코드만 읽어도 충분하다
- 변경의 영향을 쉽게 예측할 수 있다

### 1.3 복잡성은 증분적으로 축적된다

> **Complexity isn't caused by a single catastrophic error; it accumulates in lots of small chunks.**

복잡성은 하나의 치명적 실수에서 오는 것이 아니다. 작은 복잡성들이 수없이 많이 쌓여 결국 시스템 전체를 압도하게 된다.

이것이 복잡성을 다루기 어려운 근본적 이유다:
- 개별적인 작은 복잡성은 무해해 보인다 ("이 정도는 괜찮지 않을까?")
- 하지만 수백, 수천 개의 작은 복잡성이 쌓이면 시스템은 다루기 어려워진다
- 복잡성이 한꺼번에 도입되는 것이 아니므로, 한꺼번에 제거하기도 어렵다

> **핵심 통찰**: 복잡성과의 싸움은 "zero tolerance" 정신으로 임해야 한다. "사소한 복잡성이니 괜찮겠지"라는 태도가 반복되면 결국 시스템이 복잡해진다. 모든 코드 변경에서 복잡성을 조금이라도 줄이려는 노력이 필요하다.

---

## 2. 복잡성의 세 가지 증상 (Symptoms)

복잡성은 추상적인 개념이지만, 구체적인 증상으로 나타난다. Ousterhout는 세 가지 증상을 식별한다.

### 2.1 변경 증폭 (Change Amplification)

> 개념적으로 단순한 변경을 수행하기 위해 **많은 곳의 코드를 수정**해야 하는 상황.

**예시: 웹사이트 배경색 변경**

```python
# 나쁜 설계: 각 페이지에 배경색이 하드코딩
class HomePage:
    def render(self):
        return f'<body style="background: #f0f0f0">...</body>'

class AboutPage:
    def render(self):
        return f'<body style="background: #f0f0f0">...</body>'

class ContactPage:
    def render(self):
        return f'<body style="background: #f0f0f0">...</body>'

# 배경색을 바꾸려면 모든 페이지를 수정해야 한다!
```

```python
# 좋은 설계: 배경색을 한 곳에서 관리
SITE_CONFIG = {
    "background_color": "#f0f0f0"
}

class BasePage:
    def render_body(self, content):
        bg = SITE_CONFIG["background_color"]
        return f'<body style="background: {bg}">{content}</body>'

# 배경색을 바꾸려면 SITE_CONFIG 한 곳만 수정하면 된다
```

변경 증폭이 발생하면:
- 단순한 변경에 비례하지 않는 많은 노력이 든다
- 수정해야 할 곳을 빠뜨릴 위험이 있다
- 같은 변경을 여러 번 반복해야 하므로 실수가 발생하기 쉽다

### 2.2 인지 부하 (Cognitive Load)

> 개발자가 작업을 완료하기 위해 **얼마나 많은 것을 알아야 하는가**.

인지 부하는 코드의 줄 수와 반드시 비례하지 않는다. 코드가 짧아도 인지 부하가 높을 수 있다:

```java
// 짧지만 인지 부하가 높은 코드
// 이 한 줄을 이해하려면 알아야 할 것:
// - allocate()가 null을 반환할 수 있는가?
// - allocate()가 예외를 던질 수 있는가?
// - 이전에 allocate()를 호출한 적이 있는가? (중복 할당 문제)
// - 반환된 객체를 누가 해제해야 하는가?
// - 스레드 안전한가?
networkBuffer = allocate(BUFFER_SIZE);
```

인지 부하의 원인:
- **API가 복잡한 경우**: 메서드를 올바르게 사용하기 위해 알아야 할 조건이 많다
- **전역 상태(global state)**: 코드의 동작이 멀리 떨어진 다른 코드에 의존한다
- **타입 불일치나 묵시적 변환**: 데이터가 어떻게 변환되는지 추적해야 한다
- **순서 의존성**: 함수들을 특정 순서로 호출해야 하지만 이것이 명시적이지 않다

> **핵심 통찰**: 코드의 줄 수를 줄이는 것이 항상 인지 부하를 줄이는 것은 아니다. 때로는 더 많은 코드가 더 명확할 수 있다. **줄 수보다 인지 부하를 기준으로 판단하라.**

### 2.3 미지의 미지 (Unknown Unknowns)

> 작업을 수행하기 위해 어떤 코드를 수정해야 하는지, 어떤 정보를 알아야 하는지조차 **모르는** 상황.

이것은 세 가지 증상 중 **가장 위험하다**. 변경 증폭과 인지 부하는 최소한 "뭔가 어렵다"는 것을 인식할 수 있다. 하지만 Unknown Unknowns는 **문제가 있다는 것 자체를 모른다**.

**예시:**

```python
class OrderProcessor:
    def process_order(self, order):
        # 주문 처리 로직...
        self.charge_payment(order)
        self.send_confirmation(order)
        # 여기에 빠진 것이 있다:
        # - 재고 차감을 해야 한다는 것을 모름
        # - 재고 차감 코드가 InventoryManager에 있다는 것을 모름
        # - 재고 부족 시 주문을 취소해야 한다는 것을 모름
```

Unknown Unknowns이 발생하면:
- 개발자가 자신의 변경이 올바르다고 확신하지만 실제로는 버그가 있다
- 테스트에서도 발견되지 않을 수 있다 (테스트 작성자도 같은 것을 모르므로)
- 프로덕션에서야 비로소 문제가 드러난다

> **핵심 통찰**: 좋은 설계의 가장 중요한 목표 중 하나는 시스템을 **명확(obvious)** 하게 만들어 Unknown Unknowns을 최소화하는 것이다. 개발자가 코드를 읽었을 때, 수정에 필요한 모든 정보가 드러나야 한다.

### 2.4 세 가지 증상 비교

| 증상 | 질문 | 위험도 | 감지 가능성 |
|------|------|--------|------------|
| **변경 증폭** | "이거 하나 바꾸려고 여기저기 다 고쳐야 해?" | 중간 | 쉽게 인식됨 |
| **인지 부하** | "이걸 이해하려면 뭘 다 알아야 하지?" | 높음 | 어느 정도 인식됨 |
| **Unknown Unknowns** | "내가 뭘 모르는지조차 모르겠다" | **매우 높음** | **인식 불가** |

---

## 3. 복잡성의 두 가지 원인 (Causes)

복잡성의 증상을 알았다면, 이제 **무엇이** 복잡성을 유발하는지 살펴보자. Ousterhout는 두 가지 근본 원인을 식별한다.

### 3.1 의존성 (Dependencies)

> **의존성(dependency)은 특정 코드를 독립적으로 이해하거나 수정할 수 없고, 다른 코드를 함께 고려해야 하는 상황이다.**

의존성은 소프트웨어의 본질적 요소이므로 완전히 제거할 수 없다. 모듈 간에 어떤 형태로든 의존성이 있어야 모듈들이 함께 동작하여 유용한 시스템을 구성한다. 설계의 목표는 의존성을 없애는 것이 아니라 **의존성의 수를 줄이고, 남은 의존성을 단순하고 명확하게 만드는 것**이다.

**의존성이 복잡성을 유발하는 방식:**

| 의존성 → 증상 연결 |
|------------------|
| A가 B에 의존하면, B를 바꿀 때 A도 바꿔야 할 수 있다 → **변경 증폭** |
| A를 이해하려면 B도 알아야 한다 → **인지 부하** |
| A가 B에 의존한다는 사실 자체를 모를 수 있다 → **Unknown Unknowns** |

**예시: 명시적 의존성 vs 암묵적 의존성**

```java
// 명시적 의존성 — 메서드 시그니처에 드러남
public class OrderProcessor {
    private final PaymentService paymentService;

    public OrderProcessor(PaymentService paymentService) {
        this.paymentService = paymentService;
    }

    public void process(Order order) {
        paymentService.charge(order.getAmount());
    }
}
// OrderProcessor가 PaymentService에 의존한다는 것이 명확하다
```

```java
// 암묵적 의존성 — 코드에 드러나지 않음
public class OrderProcessor {
    public void process(Order order) {
        // PaymentService를 전역 레지스트리에서 가져옴
        PaymentService ps = ServiceRegistry.get(PaymentService.class);
        ps.charge(order.getAmount());
    }
}
// 의존성이 메서드 시그니처에 드러나지 않는다.
// ServiceRegistry의 상태에 따라 동작이 달라진다.
// → Unknown Unknowns의 원인
```

### 3.2 모호성 (Obscurity)

> **모호성(obscurity)은 중요한 정보가 명확하지 않은 상황이다.**

모호성은 의존성보다 더 미묘한 원인이다. 코드가 "무엇을 하는지"가 아니라 "왜 그렇게 하는지", "어떤 전제 조건이 있는지" 등이 드러나지 않는 경우 발생한다.

**모호성의 흔한 형태:**

**1. 불명확한 변수명/함수명**

```python
# 모호한 이름
def calc(a, b, t):
    if t == 1:
        return a + b
    elif t == 2:
        return a * b

# 명확한 이름
def calculate_price(base_price, tax_rate, calculation_type):
    if calculation_type == CalculationType.ADDITIVE:
        return base_price + tax_rate
    elif calculation_type == CalculationType.MULTIPLICATIVE:
        return base_price * tax_rate
```

**2. 묵시적 규칙 (Convention without documentation)**

```java
// 코드에서 드러나지 않는 규칙:
// - 이 메서드는 반드시 init() 호출 이후에 사용해야 한다
// - 반환값이 null이면 "항목 없음"을 의미한다
// - 이 메서드는 스레드 안전하지 않다
public List<Item> getItems() {
    return cache.get("items");
}
```

**3. 불일치 (Inconsistency)**

같은 패턴이 어떤 곳에서는 A 방식으로, 다른 곳에서는 B 방식으로 구현되어 있으면, 개발자는 "이 경우에는 어떤 방식이 적용되는가?"를 매번 확인해야 한다.

**모호성이 복잡성을 유발하는 방식:**

| 모호성 → 증상 연결 |
|------------------|
| 코드의 의도가 불명확하여 변경할 곳을 찾기 어렵다 → **변경 증폭** |
| 코드를 이해하기 위해 문서, 히스토리, 다른 코드를 추가로 읽어야 한다 → **인지 부하** |
| 중요한 정보가 숨겨져 있어 그 존재를 모른다 → **Unknown Unknowns** |

### 3.3 원인과 증상의 관계 정리

```
       ┌─────────────┐        ┌──────────────────┐
       │  의존성       │───────→│  변경 증폭         │
       │ (Dependencies)│───────→│  인지 부하         │
       │              │───────→│  Unknown Unknowns  │
       └─────────────┘        └──────────────────┘

       ┌─────────────┐        ┌──────────────────┐
       │  모호성       │───────→│  변경 증폭         │
       │ (Obscurity)  │───────→│  인지 부하         │
       │              │───────→│  Unknown Unknowns  │
       └─────────────┘        └──────────────────┘
```

두 원인은 독립적으로 또는 함께 작용하여 세 가지 증상을 유발한다. 복잡성을 줄이려면 의존성을 줄이고, 코드를 명확하게 만들어야 한다.

---

## 4. 복잡성은 독자의 관점에서 판단한다

Ousterhout가 강조하는 중요한 원칙:

> **If a system has a complicated implementation but the interface is simple, for most purposes the system is not complex.**

구현이 복잡해도 인터페이스가 단순하면, 사용자(다른 개발자) 관점에서 시스템은 복잡하지 않다. 반대로 구현이 단순해도 인터페이스가 복잡하면 시스템은 복잡하다.

이것은 중요한 함의를 가진다:

- **복잡성은 코드 작성자가 아니라 코드 독자가 판단한다**: "나는 이해하니까 괜찮다"는 잘못된 기준이다. 다른 개발자가 (미래의 자신 포함) 이해하기 어렵다면 복잡한 것이다.
- **가장 많이 읽히는 코드가 가장 단순해야 한다**: 자주 사용되는 인터페이스는 드물게 수정되는 구현보다 단순해야 한다.

이것이 바로 Chapter 4에서 다루는 **"깊은 모듈(Deep Module)"** 개념의 핵심이다.

---

## 5. 복잡성의 공식

Ousterhout는 복잡성을 다음과 같이 공식으로 표현한다:

```
C = Σ (cp × tp)
```

- **C**: 시스템의 전체 복잡성
- **cp**: 각 모듈 p의 복잡성
- **tp**: 개발자가 모듈 p에서 작업하는 데 소비하는 시간의 비율 (가중치)

이 공식의 핵심 통찰:

- **자주 사용되는 모듈의 복잡성이 더 중요하다**: 복잡한 모듈이라도 거의 건드리지 않는다면 전체 복잡성에 미치는 영향은 적다. 반대로 약간만 복잡해도 매일 사용하는 모듈이라면 큰 영향을 준다.
- **복잡성을 줄이는 최선의 전략**: 가장 자주 사용되는 모듈의 인터페이스를 단순하게 만드는 것이 가장 효과적이다.
- **복잡성을 격리할 수 있다**: 복잡한 구현을 거의 건드리지 않는 모듈 안에 가두면, tp가 작아져서 전체 복잡성에 미치는 영향이 줄어든다.

**예시:**

| 모듈 | 복잡성 (cp) | 사용 빈도 (tp) | 기여도 (cp × tp) |
|------|-----------|---------------|----------------|
| 파서(Parser) | 높음 (8) | 낮음 (0.05) | 0.4 |
| API 레이어 | 중간 (4) | 높음 (0.4) | **1.6** |
| 유틸 함수 | 낮음 (2) | 높음 (0.3) | 0.6 |
| 데이터 마이그레이션 | 매우 높음 (10) | 매우 낮음 (0.01) | 0.1 |

이 예시에서 전체 복잡성에 가장 큰 영향을 주는 것은 복잡성 자체가 가장 높은 모듈(데이터 마이그레이션)이 아니라, 중간 복잡도이지만 자주 사용되는 **API 레이어**다.

---

## 요약

- **복잡성**이란 시스템을 이해하고 수정하기 어렵게 만드는 모든 것이다.
- 복잡성은 세 가지 **증상**으로 나타난다:
  - **변경 증폭**: 단순한 변경에 많은 곳을 수정해야 함
  - **인지 부하**: 이해하기 위해 너무 많은 것을 알아야 함
  - **Unknown Unknowns**: 뭘 모르는지조차 모름 (가장 위험)
- 복잡성의 두 가지 **원인**:
  - **의존성**: 코드를 독립적으로 이해/수정할 수 없음
  - **모호성**: 중요한 정보가 명확하지 않음
- 복잡성은 한꺼번에 오지 않고 **작은 조각들이 축적**되어 발생한다.
- 복잡성은 **코드 독자의 관점**에서 판단해야 한다.
- 자주 사용되는 모듈의 복잡성이 전체 복잡성에 **더 큰 영향**을 미친다.

---

## 이 챕터의 Red Flags

이 챕터에서 직접적인 Red Flag가 명명되지는 않지만, 이후 챕터에서 등장하는 모든 Red Flag의 근거가 여기서 제시된다:

- 단순한 변경인데 여러 파일을 수정해야 한다면 → **변경 증폭** → 설계 문제
- 한 메서드를 이해하기 위해 다른 여러 곳을 참조해야 한다면 → **인지 부하** → 설계 문제
- "이 변경이 다른 곳에 영향을 주는가?"라는 질문에 확신 있게 답할 수 없다면 → **Unknown Unknowns** → 설계 문제

---

## 다음 챕터와의 연결

Chapter 3 **"Working Code Isn't Enough (동작하는 코드만으로는 부족하다)"** 에서는 복잡성을 유발하는 근본적인 **태도**의 문제를 다룬다. **전술적 프로그래밍(Tactical Programming)** — "일단 동작하게 만들자"는 접근 — 이 어떻게 복잡성을 축적시키는지, 그리고 **전략적 프로그래밍(Strategic Programming)** — "좋은 설계를 만들자"는 접근 — 이 장기적으로 왜 더 빠른지를 설명한다.
