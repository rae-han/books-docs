# Chapter 19: Software Trends (소프트웨어 트렌드)

## 핵심 질문

현재 소프트웨어 업계의 주요 트렌드들은 복잡성 관리에 도움이 되는가, 해가 되는가?

---

## 1. 트렌드를 평가하는 기준

Ousterhout는 모든 트렌드를 **하나의 기준**으로 평가한다:

> **이 트렌드가 소프트웨어의 복잡성을 줄이는가?**

어떤 트렌드도 무조건 좋거나 나쁘지 않다. 복잡성을 줄이면 좋은 것이고, 늘리면 나쁜 것이다.

---

## 2. 객체 지향 프로그래밍 (OOP)

### 좋은 점
- **private 필드/메서드**: 정보 은닉을 지원한다
- **인터페이스 상속**: 다형성으로 강력한 추상화를 만든다

### 주의할 점
- **구현 상속**: 부모-자식 클래스 간 강한 결합을 만든다. 부모 클래스의 변경이 자식에게 예상치 못한 영향을 줄 수 있다.

> **핵심 통찰**: 구현 상속보다 **조합(composition)** 을 선호하라. 부모 클래스가 확장을 위해 신중하게 설계된 경우에만 구현 상속을 사용한다.

---

## 3. 애자일 개발 (Agile Development)

### 좋은 점
- **증분적 개발**: Ousterhout의 증분적 설계 접근과 일치한다
- **빠른 피드백**: 설계 문제를 조기에 발견할 수 있다

### 주의할 점
- **설계 경시 위험**: "동작하는 소프트웨어가 포괄적인 문서보다 중요하다"는 원칙이 극단적으로 해석되면, 설계를 등한시하게 된다
- **전술적 프로그래밍 유도**: 빠른 반복에 집중하면 "빨리 동작하게 만들자" 마인드로 빠질 수 있다

> **Ousterhout의 입장**: 증분적으로 개발하되, 각 증분에서 **설계에 충분히 투자하라**. 애자일의 방법론은 취하되, 설계 품질은 양보하지 마라.

---

## 4. 단위 테스트 (Unit Tests)

Ousterhout는 단위 테스트를 **강하게 지지**한다:

- 리팩토링의 **안전망**: 설계 개선 시 기존 동작이 보존되는지 확인
- 경계 조건과 엣지 케이스의 **문서화**
- 코드 변경의 **자신감** 향상

---

## 5. 테스트 주도 개발 (TDD)

### Ousterhout의 우려

- TDD는 **기능 구현에 초점**을 맞추므로, 전술적 프로그래밍을 유도할 수 있다
- 테스트를 먼저 쓰면 **인터페이스가 테스트 용이성에 의해 결정**될 수 있다 (깔끔한 추상화가 아니라)
- 작은 단위의 테스트 → 작은 단위의 구현 → 얕은 모듈의 위험

> **Ousterhout의 입장**: TDD를 설계의 유일한 도구로 삼지 마라. 테스트는 **설계를 검증하는 도구**지, 설계를 이끄는 도구가 아니다. 먼저 좋은 설계를 하고, 그 다음에 테스트를 작성하는 것이 낫다.

---

## 6. 디자인 패턴 (Design Patterns)

### 좋은 점
- 공유 어휘를 제공한다 ("이건 Observer 패턴이야"로 설계 의도를 빠르게 전달)
- 검증된 해결책을 재사용한다

### 주의할 점
- **과도한 적용**: 패턴이 맞지 않는 상황에 억지로 적용하면 복잡성이 증가한다
- 패턴은 도구이지 목표가 아니다

> "The greatest risk with design patterns is over-application."

---

## 7. Getter와 Setter

Ousterhout는 모든 필드에 자동으로 getter/setter를 만드는 관행에 반대한다:

```java
// 나쁜: 모든 필드에 getter/setter → 정보 은닉이 없음
public class User {
    private String name;
    private String email;
    private int age;

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public int getAge() { return age; }
    public void setAge(int age) { this.age = age; }
}
// private이지만 실질적으로 모든 내부 상태가 노출되어 있다
```

모든 필드에 getter/setter가 있으면 **정보가 사실상 은닉되지 않는다**. 내부 표현이 바뀌면 모든 getter/setter도 바뀌어야 하고, 사용하는 모든 코드도 영향을 받는다.

> **원칙**: 정말 외부에서 접근이 필요한 경우에만 getter/setter를 만들어라. 그것도 내부 표현이 아닌 **의미 있는 추상화 수준**에서 제공하라.

---

## 요약

| 트렌드 | Ousterhout의 평가 |
|--------|------------------|
| **OOP** | 정보 은닉, 인터페이스 상속은 좋음. 구현 상속은 주의. |
| **Agile** | 증분적 개발은 좋음. 설계 경시 위험에 주의. |
| **Unit Tests** | 강하게 지지. 리팩토링의 안전망. |
| **TDD** | 혼합적. 설계를 이끄는 도구가 아니라 검증 도구로 사용. |
| **Design Patterns** | 유용하지만 과도한 적용은 해롭다. |
| **Getter/Setter** | 자동 생성 반대. 정보 은닉을 무력화한다. |

모든 트렌드를 **"복잡성을 줄이는가?"** 라는 렌즈로 평가하라.

---

## 다음 챕터와의 연결

Chapter 20 **"Designing for Performance (성능을 위한 설계)"** 에서는 성능과 깔끔한 설계의 관계를 다룬다. 좋은 설계와 좋은 성능은 대립하지 않으며, 설계 단계에서 성능을 고려하는 방법을 제시한다.
