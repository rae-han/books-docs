# Chapter 3: Working Code Isn't Enough (동작하는 코드만으로는 부족하다)

## 핵심 질문

"일단 동작하게 만들자"는 접근법이 왜 장기적으로 더 느린가? 좋은 설계를 위한 투자는 얼마만큼이 적절한가?

---

## 1. 두 가지 프로그래밍 철학

소프트웨어 개발에 대한 접근 방식은 크게 두 가지로 나뉜다.

### 1.1 전술적 프로그래밍 (Tactical Programming)

> **"일단 동작하게 만들자."**

전술적 프로그래밍의 목표는 **기능을 최대한 빨리 동작하게 만드는 것**이다. 새로운 기능이든 버그 수정이든, 가장 빠르게 결과를 내는 방법을 선택한다.

전술적 프로그래머의 사고방식:

- "지금 동작하면 된다"
- "나중에 리팩토링하면 되지"
- "설계에 시간 쓸 여유가 없다"
- "이 정도 해킹은 괜찮겠지"

### 1.2 전략적 프로그래밍 (Strategic Programming)

> **"좋은 설계를 만들자. 물론 동작도 해야 한다."**

전략적 프로그래밍의 목표는 **훌륭한 설계를 만드는 것**이다. 동작하는 코드는 필요 조건이지 충분 조건이 아니다.

전략적 프로그래머의 사고방식:

- "이 코드를 다른 개발자가 쉽게 이해하고 수정할 수 있는가?"
- "이 변경이 향후 확장을 어렵게 만들지 않는가?"
- "더 깔끔한 방법은 없는가?"

---

## 2. 전술적 프로그래밍의 문제

### 2.1 복잡성의 점진적 축적

전술적 접근의 핵심 문제는 **각 변경이 작은 복잡성을 추가**한다는 것이다.

```python
# 1차 변경: "빨리 기능 추가하자"
def process_order(order):
    # 기존 코드에 특수 케이스를 덧붙임
    if order.type == "express":
        # 급한 거니까 여기에 바로 처리 로직 추가
        handle_express(order)
        return
    # ... 기존 로직 ...

# 2차 변경: "이것도 빨리"
def process_order(order):
    if order.type == "express":
        handle_express(order)
        return
    # 또 다른 특수 케이스
    if order.country == "KR" and order.total > 50000:
        apply_korean_tax_rules(order)
    # ... 기존 로직 ...

# N차 변경 후: 특수 케이스들의 누적으로 메서드가 이해 불가능해짐
```

개별적으로 보면 각 변경은 "별거 아닌" 수준이다. 하지만 이런 변경이 수백 번 반복되면 시스템은 걷잡을 수 없이 복잡해진다.

> **핵심 통찰**: 복잡성은 한 번의 큰 실수가 아니라 **수백 번의 작은 타협**에서 온다. "이 정도는 괜찮겠지"라는 생각이 반복되면 시스템은 복잡해진다.

### 2.2 전술적 토네이도 (Tactical Tornado)

Ousterhout는 **전술적 토네이도(Tactical Tornado)** 라는 개발자 유형을 소개한다:

> 전술적 토네이도는 엄청나게 빠른 속도로 코드를 쏟아내는 개발자다. 기능을 빠르게 구현하므로 관리자에게는 영웅으로 보인다. 하지만 그가 지나간 자리에는 파괴의 흔적이 남는다.

전술적 토네이도의 특징:
- 놀라울 정도로 빠르게 기능을 구현한다
- 관리자와 동료에게 "일 잘하는 사람"으로 인식된다
- 하지만 코드는 읽기 어렵고, 테스트하기 어렵고, 수정하기 어렵다
- 다른 개발자들이 그 코드를 유지보수하는 데 수배의 시간을 소비한다

> **핵심 통찰**: 전술적 토네이도가 만들어낸 코드를 정리하는 비용은 처음에 전략적으로 작성했을 때의 비용보다 훨씬 크다.

---

## 3. 전략적 프로그래밍의 실천

### 3.1 투자 마인드셋 (Investment Mindset)

전략적 프로그래밍은 **투자(investment)** 의 관점에서 접근한다:

- **선제적 투자 (Proactive Investment)**: 지금 당장 필요하지 않더라도 좋은 설계를 위해 시간을 투자한다
  - 여러 설계 대안을 비교하고 최선을 선택한다
  - 명확한 문서와 주석을 작성한다
  - 깔끔한 추상화를 만든다

- **반응적 투자 (Reactive Investment)**: 설계 문제를 발견하면 즉시 고친다
  - 버그를 수정할 때 근본 원인을 해결한다 (증상만 가리지 않는다)
  - 코드를 읽다가 불명확한 부분을 발견하면 개선한다
  - 새 기능 추가 시 기존 설계가 맞지 않으면 설계를 개선한다

### 3.2 얼마나 투자해야 하는가

Ousterhout는 전체 개발 시간의 약 **10~20%** 를 설계에 투자할 것을 제안한다.

| 항목 | 전술적 접근 | 전략적 접근 |
|------|-----------|-----------|
| 단기 속도 | 빠름 | 10~20% 느림 |
| 코드 품질 | 점진적 악화 | 점진적 개선 |
| 6개월 후 | 복잡성 축적으로 느려짐 | 투자 회수 시작 |
| 1~2년 후 | 심각한 기술 부채 | 깨끗한 코드베이스로 생산성 유지 |

```
생산성
  ^
  |  전술적 ───────────
  |  접근     ╲
  |            ╲
  |             ╲────────── (기술 부채로 생산성 급감)
  |
  |  전략적     ╱──────────── (투자 회수로 생산성 상승)
  |  접근  ╱
  |  ────
  +──────────────────────────→ 시간
       ↑
     이 시점에서 전략적 접근이 역전
    (Ousterhout: 수개월 이내)
```

> **핵심 통찰**: 전략적 접근은 거대한 선행 투자(Big Design Up Front)가 아니다. 매일 매일의 코딩에서 **조금씩** 더 나은 설계를 선택하는 것이다. 10~20%의 추가 시간은 수개월 내에 회수된다.

---

## 4. 스타트업과 전략적 프로그래밍

### 4.1 흔한 반론: "빨리 출시해야 한다"

스타트업에서 흔히 듣는 주장:

> "우리는 빨리 시장에 나가야 한다. 설계에 시간 쓸 여유가 없다. 나중에 성공하면 그때 코드를 정리하겠다."

Ousterhout는 이 주장에 강하게 반박한다:

- **"나중에 정리"는 거의 일어나지 않는다**: 성공하면 새로운 기능 요구가 쏟아지고, 정리할 시간은 영원히 오지 않는다
- **기술 부채는 생각보다 빨리 쌓인다**: 몇 개월만에 코드베이스가 다루기 어려워진다
- **첫 번째 버전이 성공 여부를 결정하지 않는다**: 스타트업의 성패는 보통 여러 번의 방향 전환(pivot) 후에 결정된다. 깨끗한 코드는 빠른 방향 전환을 가능하게 한다

### 4.2 사례: Facebook vs Google

**Facebook**: "Move fast and break things" 문화

- 극도의 전술적 접근으로 빠르게 성장했다
- 하지만 시간이 지나면서 코드베이스의 복잡성이 심각해졌다
- 결국 슬로건을 "Move fast with stable infra"로 바꿔야 했다
- 기술 부채를 해결하는 데 막대한 비용이 들었다

**Google, VMware**: 초기부터 전략적 접근

- 코드 품질과 설계에 높은 기준을 유지했다
- 장기적으로 더 빠른 개발 속도를 달성했다
- 깨끗한 코드베이스 위에서 신규 기능을 빠르게 추가할 수 있었다

> **핵심 통찰**: 가장 성공적인 기업들이 반드시 가장 전술적이었던 것은 아니다. 오히려 많은 경우 전략적 접근을 취한 기업들이 장기적으로 더 빠르게 성장했다.

---

## 5. 실무에서의 적용

### 5.1 매일의 습관

전략적 프로그래밍은 특별한 행사가 아니라 **매일의 습관**이다:

- 코드를 작성할 때: "이보다 더 깔끔한 방법이 있을까?" 잠시 멈추고 생각한다
- 코드를 읽을 때: 이해하기 어려운 부분을 발견하면 개선한다
- 버그를 수정할 때: 증상뿐 아니라 근본 원인을 해결한다
- 코드 리뷰할 때: 동작 여부뿐 아니라 설계 품질도 확인한다

### 5.2 절대 하지 말아야 할 것

- "일단 동작하게 만들고, TODO 주석을 남기자" → TODO는 영원히 해결되지 않는다
- "시간이 없으니 이번만 예외로" → 예외가 규칙이 된다
- "나중에 리팩토링 스프린트를 하자" → 리팩토링 스프린트는 거의 승인되지 않는다

---

## 요약

- 소프트웨어 개발에는 **전술적 프로그래밍**("빨리 동작하게")과 **전략적 프로그래밍**("좋은 설계로")의 두 가지 접근이 있다.
- 전술적 접근은 단기적으로 빨라 보이지만, 복잡성이 축적되어 **장기적으로 느려진다**.
- **전술적 토네이도**는 빠르게 코드를 쏟아내지만, 뒤에 파괴적인 복잡성을 남긴다.
- 전략적 프로그래밍은 전체 시간의 **10~20%** 정도의 추가 투자로, 수개월 내에 회수된다.
- "나중에 정리하겠다"는 거의 일어나지 않는다. **지금** 좋은 설계를 추구하라.
- 전략적 프로그래밍은 매일의 작은 습관이다.

---

## 다음 챕터와의 연결

Chapter 4 **"Modules Should Be Deep (모듈은 깊어야 한다)"** 에서는 전략적 프로그래밍의 핵심 도구인 **깊은 모듈(Deep Module)** 개념을 소개한다. 단순한 인터페이스 뒤에 강력한 기능을 숨기는 깊은 모듈은 복잡성을 관리하는 가장 중요한 메커니즘이며, 이 책의 가장 중심적인 개념이다.
