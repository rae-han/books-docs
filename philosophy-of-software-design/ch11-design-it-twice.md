# Chapter 11: Design it Twice (두 번 설계하라)

## 핵심 질문

왜 첫 번째 설계 아이디어에 바로 뛰어들면 안 되는가? 대안을 비교하는 과정이 어떻게 더 나은 설계로 이끄는가?

---

## 1. 핵심 원칙

> **중요한 설계 결정을 내릴 때, 첫 번째 떠오른 아이디어에 만족하지 말고 최소 2~3개의 대안을 고려한 후 비교하여 선택하라.**

소프트웨어 설계는 어렵다. 첫 번째 아이디어가 최선일 가능성은 높지 않다. 대안을 고려하는 행위 자체가 설계의 품질을 높인다.

> "Designing software is hard, so it's unlikely that your first thoughts about how to structure a module or system will produce the best design. You'll end up with a much better result if you consider multiple options for each major design decision."

---

## 2. 어떻게 두 번 설계하는가

### 2.1 과정

1. **대안 스케치**: 중요한 설계 결정에 대해 2~3개의 근본적으로 다른 접근법을 스케치한다
2. **비교**: 각 대안의 장단점을 비교한다
3. **선택**: 가장 깔끔한 설계를 선택하거나, 여러 대안의 좋은 부분을 조합한다

### 2.2 대안은 "근본적으로" 달라야 한다

사소한 변형이 아니라 근본적으로 다른 접근법을 고려해야 한다.

```
예: 텍스트 에디터의 텍스트 저장 방식

대안 A: 줄 단위 배열 (Array of Lines)
- 각 줄을 문자열로, 전체 텍스트를 배열로 저장
- 장점: 구현이 단순, 줄 단위 접근이 빠름
- 단점: 큰 파일에서 줄 중간 삽입/삭제가 느림

대안 B: 문자 단위 연결 리스트 (Linked List of Characters)
- 각 문자를 노드로, 연결 리스트로 저장
- 장점: 어디서든 삽입/삭제가 O(1)
- 단점: 메모리 오버헤드 큼, 캐시 효율 나쁨

대안 C: Gap Buffer
- 현재 커서 위치에 빈 공간(gap)을 두는 배열
- 장점: 커서 근처 편집이 빠르고 메모리 효율적
- 단점: 커서가 멀리 이동하면 gap 재배치 비용

대안 D: Piece Table
- 원본 텍스트 + 추가 버퍼 + 조각(piece) 테이블
- 장점: 대용량 파일에 효율적, undo 구현이 자연스러움
- 단점: 구현이 복잡
```

이렇게 비교하면 각 접근법의 트레이드오프가 명확해진다.

### 2.3 비교 기준

대안들을 비교할 때 다음 기준을 적용한다:

| 기준 | 질문 |
|------|------|
| **인터페이스 단순성** | 사용자(호출자)에게 더 간단한 인터페이스를 제공하는가? |
| **범용성** | 현재뿐 아니라 미래의 사용 사례도 자연스럽게 지원하는가? |
| **성능** | 핵심 연산의 성능 특성이 어떠한가? |
| **구현 용이성** | 구현이 얼마나 복잡한가? 버그 가능성은? |

---

## 3. 구체적 예시: 텍스트 에디터 Undo 시스템

### 대안 A: 명령 객체 스택

```java
interface UndoableAction {
    void undo();
    void redo();
}

class InsertAction implements UndoableAction {
    private int position;
    private String text;

    public void undo() { buffer.delete(position, text.length()); }
    public void redo() { buffer.insert(position, text); }
}

class UndoManager {
    private Stack<UndoableAction> undoStack;
    private Stack<UndoableAction> redoStack;

    public void undo() { /* 스택에서 꺼내서 undo 호출 */ }
    public void redo() { /* redoStack에서 꺼내서 redo 호출 */ }
}
```

- **장점**: 각 동작이 독립적, 새로운 동작 유형 추가가 쉬움
- **단점**: 동작마다 클래스 필요, 복합 동작(여러 글자 삽입 = 하나의 undo) 처리가 복잡

### 대안 B: 상태 스냅샷

```java
class UndoManager {
    private Stack<DocumentState> snapshots;

    public void checkpoint() {
        snapshots.push(document.getState());
    }

    public void undo() {
        document.restoreState(snapshots.pop());
    }
}
```

- **장점**: 구현이 매우 단순, 어떤 변경이든 undo 가능
- **단점**: 메모리 사용량이 큼 (매번 전체 상태 저장), 큰 문서에서 비실용적

### 대안 C: 변경 로그 (Change Log)

```java
class UndoManager {
    private List<Change> log;  // 모든 변경을 순서대로 기록

    record Change(int position, String deleted, String inserted) {}

    public void undo() {
        Change last = log.removeLast();
        buffer.delete(last.position(), last.inserted().length());
        buffer.insert(last.position(), last.deleted());
    }
}
```

- **장점**: 메모리 효율적 (변경 부분만 저장), 범용적
- **단점**: 복합 동작 그룹화 로직 필요

### 비교 결과

| 기준 | 명령 객체 | 스냅샷 | 변경 로그 |
|------|----------|--------|----------|
| 인터페이스 단순성 | 보통 | 높음 | 높음 |
| 메모리 효율 | 좋음 | 나쁨 | 좋음 |
| 구현 복잡도 | 높음 | 낮음 | 중간 |
| 확장성 | 좋음 | 나쁨 | 좋음 |

이런 비교를 거치면, 첫 번째 떠오른 아이디어가 아닌 **상황에 가장 적합한 설계**를 선택할 수 있다.

---

## 4. 개발자들이 저항하는 이유

### 4.1 "나는 충분히 똑똑하니까 처음부터 맞출 수 있다"

Ousterhout의 반론:

> 당신이 아무리 뛰어나도, 대안을 비교하면 더 나은 결과를 얻는다. 그리고 대안을 떠올리기 어렵다면, 그것은 경험이 부족하다는 신호이며, 대안 비교가 더더욱 필요하다는 뜻이다.

### 4.2 "시간이 없다"

대안 비교는 전체 구현이 아니다. **인터페이스 수준의 스케치**면 충분하다. 메서드 시그니처, 핵심 데이터 구조, 주요 동작만 스케치하면 된다. 이 과정은 30분~1시간이면 충분하다.

잘못된 설계로 구현을 시작해서 나중에 전체를 뒤엎는 비용에 비하면, 대안 비교에 투자하는 시간은 미미하다.

### 4.3 "이미 좋은 설계를 알고 있다"

그렇다 하더라도 대안을 비교하면 현재 설계에 대한 **확신**이 생긴다. "왜 이 설계가 최선인가?"라는 질문에 "다른 대안 A, B와 비교했을 때 이러이러한 이유로"라고 명확히 답할 수 있게 된다.

---

## 5. 언제 적용하는가

"두 번 설계하라"를 모든 결정에 적용할 필요는 없다. 다음과 같은 **중요한 결정**에 적용한다:

- **모듈의 인터페이스 설계**: 모듈의 공개 API를 처음 정할 때
- **핵심 데이터 구조 선택**: 시스템의 성능과 구조를 좌우하는 데이터 구조
- **아키텍처 결정**: 시스템의 전체 구조를 결정하는 선택
- **나중에 바꾸기 비싼 결정**: 한 번 결정하면 되돌리기 어려운 것들

사소한 결정(지역 변수 이름, 작은 유틸리티 메서드의 구현 등)에는 적용할 필요가 없다.

---

## 6. 설계 능력 향상의 도구

> **핵심 통찰**: "두 번 설계하라"는 단순한 설계 기법이 아니라 **설계 능력을 향상시키는 훈련**이기도 하다. 대안을 비교하는 과정에서 트레이드오프를 분석하는 능력이 길러지고, 시간이 지나면 처음 떠올리는 아이디어의 품질 자체가 높아진다.

---

## 요약

- 중요한 설계 결정에서 **최소 2~3개의 근본적으로 다른 대안**을 고려하라.
- 대안은 사소한 변형이 아니라 **근본적으로 다른 접근법**이어야 한다.
- 전체 구현이 아닌 **인터페이스 수준의 스케치**로 비교하므로 시간이 많이 들지 않는다.
- 비교 기준: 인터페이스 단순성, 범용성, 성능, 구현 용이성.
- 대안을 떠올리기 어렵다면, 그것은 대안 비교가 **더 필요하다**는 신호다.
- 이 과정은 당장의 설계뿐 아니라 **장기적인 설계 능력 향상**에도 기여한다.

---

## 다음 챕터와의 연결

Chapter 12 **"Why Write Comments? The Four Excuses (왜 주석을 써야 하는가)"** 에서는 소프트웨어 설계의 또 다른 핵심 도구인 **주석**을 다룬다. 많은 개발자가 주석을 쓰지 않는 네 가지 변명과, 주석이 왜 단순한 문서화가 아니라 **설계 도구**로서 중요한지를 설명한다.
