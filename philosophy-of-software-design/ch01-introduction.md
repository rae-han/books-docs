# Chapter 1: Introduction (모든 것은 복잡성에 관한 것이다)

## 핵심 명제

> **소프트웨어 설계에서 가장 근본적인 문제는 복잡성(complexity)이다.**

모든 소프트웨어 구축 행위는 본질적으로 복잡성과의 싸움이다. 이 책은 복잡성이 무엇인지, 어떻게 발생하는지, 그리고 어떻게 최소화할 수 있는지를 다룬다.

---

## 1. 소프트웨어 설계는 왜 어려운가

### 1.1 소프트웨어의 본질적 특성

물리적 시스템(건물, 다리, 선박)은 설계가 완료된 후 시공에 들어간다. 설계와 구현이 명확히 분리되어 있다. 하지만 소프트웨어는 다르다:

- **설계와 구현이 얽혀 있다**: 소프트웨어는 설계하면서 동시에 구현한다. 코드를 작성하는 행위 자체가 설계 행위다.
- **완성된 설계란 없다**: 소프트웨어는 끊임없이 변경된다. 초기 설계가 아무리 좋아도, 이후의 변경이 설계를 훼손할 수 있다.
- **물리적 제약이 없다**: 건물은 물리 법칙의 제약 안에서 설계하지만, 소프트웨어는 추상적이어서 복잡성에 대한 자연적 제한이 없다. 따라서 복잡성이 무한히 커질 수 있다.

### 1.2 교육의 부재

대부분의 CS 교육은 알고리즘, 자료구조, 프로그래밍 언어에 집중한다. **소프트웨어 설계**에 대한 체계적인 교육은 놀라울 정도로 부족하다. Ousterhout는 이것이 큰 문제라고 지적한다:

> 프로그래밍을 배우는 것과 소프트웨어 설계를 배우는 것은 전혀 다른 일이다. 프로그래밍은 코드를 작성하는 기술이고, 설계는 코드의 구조를 결정하는 기술이다.

설계 능력은 주로 경험을 통해 암묵적으로 습득되는데, 이것은 비효율적이다. 이 책의 목표는 소프트웨어 설계의 원칙을 **명시적으로** 정리하여 학습 가능하게 만드는 것이다.

---

## 2. 복잡성을 다루는 두 가지 접근법

Ousterhout는 소프트웨어 복잡성을 다루는 접근법을 크게 두 가지로 분류한다:

### 2.1 복잡성 제거 (Eliminate Complexity)

코드를 더 단순하고 명확하게 만들어 복잡성 자체를 없앤다.

- 특수한 경우(special case)를 제거하여 일반적인 경우만 남긴다
- 불필요한 추상화 계층을 제거한다
- 코드의 의도를 명확하게 드러낸다

### 2.2 복잡성 캡슐화 (Encapsulate Complexity)

복잡성을 완전히 없앨 수 없다면, 모듈 안에 가두어 한 번에 다뤄야 하는 복잡성의 양을 줄인다.

- **모듈화(Modular Design)**: 시스템을 독립적인 모듈로 나누어, 각 모듈을 작업할 때 다른 모듈의 복잡성을 알 필요가 없도록 한다.
- **정보 은닉(Information Hiding)**: 설계 결정을 모듈 내부에 숨겨, 외부에서는 단순한 인터페이스만 보이도록 한다.

> **핵심 통찰**: 이 두 접근법은 상호 배타적이지 않다. 좋은 설계는 가능한 한 복잡성을 제거하고, 남은 복잡성은 캡슐화하여 개발자가 한 번에 다뤄야 하는 복잡성의 양을 최소화한다.

---

## 3. 이 책의 접근 방식

### 3.1 문제 분해(Problem Decomposition)가 핵심

Ousterhout는 소프트웨어 설계의 핵심이 **문제 분해(problem decomposition)** 라고 본다:

> 소프트웨어 설계란 큰 소프트웨어 시스템을 비교적 독립적인 모듈들로 나누는 것이다.

이 분해가 잘 되면:
- 각 모듈을 독립적으로 이해하고 수정할 수 있다
- 한 모듈의 변경이 다른 모듈에 영향을 주지 않는다
- 시스템 전체를 한꺼번에 이해하지 않아도 작업할 수 있다

분해가 잘못 되면:
- 모듈 사이의 의존성이 많아서 하나를 바꾸면 여러 곳을 수정해야 한다
- 기능이 여러 모듈에 흩어져 있어서 전체를 읽어야 한다
- 복잡성이 캡슐화되지 않고 시스템 전체에 퍼진다

### 3.2 증분적 접근 (Incremental Approach)

소프트웨어 설계는 한 번에 완성할 수 없다. Ousterhout는 **증분적 접근(incremental approach)** 을 강조한다:

> 소프트웨어 시스템은 처음에 설계되고, 그 후 기능 추가와 버그 수정을 통해 끊임없이 진화한다. 따라서 소프트웨어 설계는 일회성 활동이 아니라 **시스템의 수명 전체에 걸친 지속적인 활동**이다.

이것은 중요한 함의를 가진다:

- **초기 설계가 완벽할 필요는 없다**: 하지만 좋은 초기 설계는 이후 진화의 기반이 된다.
- **코드를 수정할 때마다 설계가 영향을 받는다**: 기능 추가가 설계를 개선할 수도, 훼손할 수도 있다.
- **지속적인 설계 개선이 필요하다**: 기능만 추가하고 설계를 방치하면 시스템은 점점 복잡해진다.

### 3.3 Waterfall vs Agile에 대한 입장

Ousterhout는 **Waterfall(폭포수 모델)** 과 **Agile(애자일)** 모두의 한계를 지적한다:

- **Waterfall의 문제**: 소프트웨어 설계를 구현 전에 완성하려 한다. 하지만 실제로 코드를 작성해봐야 비로소 드러나는 문제가 많다. 설계를 한 번에 완성한다는 전제 자체가 비현실적이다.
- **Agile의 문제**: 증분적 개발을 강조하는 것은 좋지만, 극단적인 경우 설계를 경시하게 된다. "동작하는 코드"를 빨리 만드는 데 집중하다 보면 전체적인 설계 품질이 떨어질 수 있다.

Ousterhout의 입장은 이 둘의 절충이다:

> 증분적으로 개발하되, 각 증분(increment)에서 **설계에 대해 깊이 생각하라**. 현재 요구사항만 충족시키는 최소한의 코드가 아니라, 향후 변경까지 고려한 깔끔한 설계를 추구하라.

이것이 Chapter 3에서 다루는 **전략적 프로그래밍(Strategic Programming)** 의 핵심이다.

---

## 4. "좋은 설계"의 기준

그렇다면 좋은 설계란 무엇인가? Ousterhout는 이렇게 정의한다:

> **좋은 설계란 시스템의 복잡성을 최소화하는 설계다.**

이 정의의 함의:

- **성능이 최우선이 아니다**: 물론 성능도 중요하지만, 설계의 일차적 목표는 복잡성 관리다. 성능 최적화는 Chapter 20에서 별도로 다룬다.
- **코드의 줄 수가 아니다**: 짧은 코드가 반드시 좋은 설계는 아니다. 때로는 더 많은 코드가 더 명확할 수 있다.
- **패턴 적용이 아니다**: 디자인 패턴을 많이 사용한다고 좋은 설계가 되는 것이 아니다. 패턴은 도구일 뿐이다.

좋은 설계의 궁극적 척도:

> 시스템을 수정해야 하는 개발자가 **쉽고 빠르게, 적은 버그로** 변경을 완료할 수 있는가?

---

## 5. 이 책의 구성

Ousterhout는 이 책에서 다루는 내용을 크게 세 가지로 분류한다:

### 5.1 복잡성의 본질 (Chapter 2)
- 복잡성이 정확히 무엇인지 정의
- 복잡성의 증상과 원인 분석

### 5.2 설계 원칙 (Chapter 3~11)
- 복잡성을 줄이는 구체적인 설계 원칙들
- 각 원칙의 Red Flag (위반 징후)

### 5.3 실무 적용 (Chapter 12~22)
- 주석, 이름 짓기 등 일상적 코딩에서의 적용
- 기존 코드 수정, 일관성 유지
- 소프트웨어 트렌드에 대한 비판적 시각

---

## 요약

- 소프트웨어 설계의 가장 근본적인 문제는 **복잡성 관리**다.
- 복잡성을 다루는 두 가지 방법: **제거**하거나 **캡슐화**한다.
- 설계의 핵심은 **문제 분해(problem decomposition)** — 시스템을 독립적인 모듈로 잘 나누는 것이다.
- 소프트웨어 설계는 일회성 활동이 아니라 **시스템 수명 전체에 걸친 지속적 활동**이다.
- 좋은 설계의 궁극적 척도: 개발자가 시스템을 **쉽고 빠르게, 적은 버그로** 수정할 수 있는가?
- 이 책은 **명시적인 설계 원칙**과 **Red Flag**를 제시하여 설계 능력을 체계적으로 학습할 수 있도록 한다.

---

## 다음 챕터와의 연결

Chapter 2 **"The Nature of Complexity (복잡성의 본질)"** 에서는 복잡성을 정밀하게 정의하고, 복잡성이 나타나는 **세 가지 증상**과 복잡성을 유발하는 **두 가지 원인**을 분석한다. 이 정의는 이후 모든 챕터의 설계 원칙이 "왜 그래야 하는지"를 판단하는 기준이 된다.
