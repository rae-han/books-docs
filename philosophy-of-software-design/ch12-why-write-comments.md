# Chapter 12: Why Write Comments? The Four Excuses (왜 주석을 써야 하는가: 네 가지 변명)

## 핵심 질문

"좋은 코드는 스스로 설명한다"는 말은 사실인가? 개발자들이 주석을 쓰지 않는 이유는 정당한가?

---

## 1. 주석에 대한 Ousterhout의 입장

Ousterhout는 주석에 대해 매우 강한 입장을 취한다:

> **주석은 좋은 소프트웨어 설계의 핵심 요소다. 주석 없이는 추상화를 정의할 수 없고, 추상화 없이는 복잡성을 관리할 수 없다.**

주석이 단순한 "문서화"가 아니라 **설계 도구**라는 것이 이 장의 핵심 메시지다.

---

## 2. 네 가지 변명

### 변명 1: "좋은 코드는 스스로 설명한다" (Good code is self-documenting)

이것은 개발자들이 주석을 쓰지 않는 가장 흔한 이유이자, Ousterhout가 가장 강하게 반박하는 주장이다.

**코드가 표현할 수 있는 것:**
- 무엇을 하는가 (what): 변수에 값을 할당, 조건 분기, 반복 등
- 어떻게 하는가 (how): 알고리즘의 단계, 데이터 변환

**코드가 표현할 수 없는 것:**
- **왜** 이 방식을 선택했는가 (why): 다른 대안이 있었지만 이것을 선택한 이유
- **제약 조건**: 파라미터의 유효 범위, 호출 순서 의존성
- **높은 수준의 의도**: 이 모듈/클래스의 전체적인 목적과 역할
- **비자명한 동작**: 경계 조건, 부수 효과, 성능 특성

```java
// 코드만으로는 "왜"를 알 수 없는 예시
private static final int RETRY_LIMIT = 3;

// 코드가 말하는 것: "재시도 한도는 3이다"
// 코드가 말할 수 없는 것:
// - 왜 3인가? (경험적으로 3번이면 일시적 장애의 95%가 복구됨)
// - 왜 고정값인가? (동적 조정을 시도했으나 오히려 불안정해짐)
// - 이 값을 바꾸면 어떤 영향이 있는가? (SLA에 영향을 줌)
```

> **핵심 통찰**: 코드의 이름과 구조가 아무리 좋아도, 모듈의 사용자가 모듈을 올바르게 사용하기 위해 **구현을 읽어야 한다면** 추상화가 존재하지 않는 것이다. 주석이 추상화를 정의한다.

### 변명 2: "주석 쓸 시간이 없다" (I don't have time)

**반론:**

- 전략적 프로그래밍(Ch 3)의 관점에서, 주석은 설계 투자의 일부다
- 좋은 주석은 **미래의 모든 독자**가 코드를 이해하는 시간을 절약한다
- 주석을 쓰는 데 드는 비용 < 주석이 없어서 코드를 해독하는 데 드는 비용

```
주석 작성 비용: 개발자 1명 × 5분
주석 부재 비용: 독자 N명 × 각 30분~1시간 (코드를 읽고 의미를 파악)
```

### 변명 3: "주석은 금방 구식이 되어 오해를 유발한다" (Comments get out of date)

**반론:**

- 이것은 부분적으로 사실이다. 하지만 해결책은 주석을 포기하는 것이 아니라 **주석을 유지하는 습관**을 기르는 것이다
- 주석을 코드 가까이에 둔다 (관련 코드와 같은 위치)
- 코드 변경 시 주석도 함께 업데이트한다
- 코드 리뷰에서 주석의 정확성을 확인한다
- **인터페이스 수준 주석**은 구현 변경에 영향을 덜 받으므로 더 안정적이다

### 변명 4: "내가 본 주석은 전부 쓸모없었다" (Comments I've seen are all worthless)

**반론:**

- 대부분의 주석이 나쁜 것은 사실이다 (코드를 반복하거나, 모호하거나)
- 하지만 해결책은 주석을 쓰지 않는 것이 아니라 **좋은 주석을 쓰는 것**이다
- Chapter 13에서 좋은 주석 작성법을 다룬다

---

## 3. 나쁜 주석 vs 좋은 주석

### 3.1 코드를 반복하는 주석 (나쁜)

```java
// 나쁜 주석: 코드를 그대로 반복
int count = 0;  // count를 0으로 초기화한다
for (Item item : items) {  // items를 순회한다
    if (item.isActive()) {  // item이 active이면
        count++;  // count를 증가시킨다
    }
}
return count;  // count를 반환한다
```

이 주석들은 **가치가 제로**다. 코드를 한국어로 번역한 것에 불과하다.

### 3.2 코드에 없는 정보를 추가하는 주석 (좋은)

```java
/**
 * 현재 활성 상태인 항목의 수를 반환한다.
 *
 * "활성"이란 isActive()가 true인 항목을 의미하며,
 * 최근 30일 이내에 마지막으로 접근된 항목이 해당된다.
 * 비용이 O(n)이므로, 반복 호출 시 결과를 캐싱하는 것을 권장한다.
 *
 * @return 활성 항목 수. 항목이 없으면 0.
 */
public int getActiveCount() {
    ...
}
```

이 주석은:
- "활성"의 정확한 의미를 정의한다 (코드에서 알 수 없음)
- 성능 특성을 알려준다 (코드를 분석하지 않으면 모름)
- 사용 가이드를 제공한다 (캐싱 권장)

---

## 4. 주석은 설계 도구다

> **핵심 통찰**: 주석의 가장 중요한 역할은 문서화가 아니라 **추상화 정의**다.

모듈의 인터페이스 주석은 그 모듈의 **추상화를 정의**한다. 주석이 없으면:
- 사용자가 모듈의 추상화를 파악하기 위해 구현을 읽어야 한다
- 추상화가 명시적으로 정의되지 않으므로 사람마다 다르게 해석할 수 있다
- Unknown Unknowns가 발생할 가능성이 높아진다

주석이 있으면:
- 사용자는 주석(인터페이스)만 읽고 모듈을 올바르게 사용할 수 있다
- 추상화가 명확히 정의되어 오해의 여지가 줄어든다
- 주석을 작성하는 과정에서 **설계 문제가 드러난다** (Chapter 15에서 자세히)

---

## 요약

- "좋은 코드는 스스로 설명한다"는 **부분적으로만** 사실이다. 코드는 "무엇"과 "어떻게"는 표현하지만 "왜"는 표현할 수 없다.
- 주석을 쓰지 않는 네 가지 변명은 모두 반박 가능하다.
- **나쁜 주석**: 코드를 반복하거나, 모호하거나, 구식이 된 주석.
- **좋은 주석**: 코드에서 알 수 없는 정보(의도, 제약, 성능 특성, 설계 이유)를 전달하는 주석.
- 주석의 가장 중요한 역할은 문서화가 아니라 **추상화를 정의하는 것**이다.
- 주석은 **설계 도구**다. 주석을 먼저 작성하면 설계 문제를 일찍 발견할 수 있다.

---

## 다음 챕터와의 연결

Chapter 13 **"Comments Should Describe Things That Aren't Obvious (주석은 명확하지 않은 것을 설명해야 한다)"** 에서는 좋은 주석을 작성하는 구체적인 방법을 다룬다. 인터페이스 주석, 구현 주석, 변수 주석 등 주석의 유형별 작성 지침과, 나쁜 주석을 구분하는 Red Flag를 제시한다.
