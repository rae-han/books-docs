# Chapter 1: Multi-Currency Money (다중 통화 Money)

## 핵심 질문

TDD는 어떻게 시작하는가? 해결하고 싶은 문제가 있을 때, 첫 번째 테스트는 무엇을 작성해야 하며, 그 테스트를 어떻게 통과시키는가?

---

## 1. 문제 설정: 다중 통화 보고서

### 1.1 배경

Kent Beck은 WyCash라는 채권 포트폴리오 관리 시스템에서의 실제 경험을 바탕으로 예제를 구성한다. 이 시스템에서는 다중 통화를 지원해야 했다.

다음과 같은 보고서를 만들어야 한다고 하자:

| 종목 | 주식 수 | 가격 | 합계 |
|------|---------|------|------|
| IBM | 1000 | 25 USD¹ | 25,000 USD |
| Novartis | 400 | 150 CHF² | 60,000 CHF |
| | | | **합계** |

<sub>¹ USD — 미국 달러(United States Dollar)</sub><br>
<sub>² CHF — 스위스 프랑(Swiss Franc, Confoederatio Helvetica Franc)</sub>

이 보고서에서 합계를 계산하려면, 서로 다른 통화(USD와 CHF)를 **환율**을 적용하여 하나의 통화로 변환해야 한다.

환율 테이블:

| From | To | Rate |
|------|----|------|
| CHF | USD | 1.5 |

즉, 1.5 CHF = 1 USD(1.5프랑이 1달러)이므로, 합계는 `25,000 USD + (60,000 CHF ÷ 1.5) = 25,000 + 40,000 = 65,000 USD`가 되어야 한다.

### 1.2 필요한 기능 분석

다중 통화 보고서를 구현하기 위해 해결해야 할 것들을 목록으로 정리한다. Kent Beck은 이것을 **TODO 리스트**라고 부른다:

## TODO 리스트

- [ ] $5 + 10 CHF = $10 (환율이 2:1인 경우)
- [ ] **$5 × 2 = $10**
- [ ] amount를 private으로 만들기
- [ ] Dollar 부작용(side effect)?
- [ ] Money 반올림?

> **핵심 통찰**: TDD에서는 작업을 시작하기 전에 해야 할 일의 목록을 작성한다. 이 목록은 완벽할 필요가 없다 — 작업하면서 항목을 추가하거나 삭제할 수 있다. 중요한 것은 **머릿속에 떠도는 아이디어를 종이 위에 꺼내놓는 것**이다. 그래야 현재 작업에 집중할 수 있다.

Kent Beck은 전체 문제(`$5 + 10 CHF = $10`)에서 시작하지 않는다. 그것은 너무 큰 첫 걸음이다. 대신 더 작은 문제인 **`$5 × 2 = $10`**(단일 통화의 곱하기)부터 시작한다.

---

## 2. TDD 사이클

### 2.1 Red — 실패하는 테스트 작성

첫 번째 테스트를 작성한다. 아직 `Dollar` 클래스도, `times` 메서드도 존재하지 않는다:

```java
public void testMultiplication() {
    Dollar five = new Dollar(5);
    five.times(2);
    assertEquals(10, five.amount);
}
```

이 테스트에는 여러 문제가 있다는 것을 Kent Beck도 알고 있다:

- `amount`가 public이다 (캡슐화 위반)
- `Dollar`을 int가 아니라 객체로 만든 이유가 아직 명확하지 않다
- 부작용(side effect)이 있다 — `times()`가 `five` 객체 자체를 변경한다
- 반올림 문제를 무시하고 있다

하지만 **이 모든 문제를 TODO 리스트에 추가하고, 지금은 테스트를 통과시키는 것에만 집중한다.**

> **핵심 통찰**: TDD의 첫 번째 원칙 — 완벽한 테스트를 쓰려고 하지 마라. 문제를 인식했다면 TODO 리스트에 적고, 현재 작업에 집중하라. 한 번에 하나씩만 해결한다.

이 테스트는 당연히 **컴파일조차 되지 않는다**. `Dollar` 클래스가 없기 때문이다. Kent Beck은 이것을 **Red Bar** — 실패한 테스트 — 로 간주한다. 컴파일 실패도 실패의 일종이다.

### 2.2 Green — 최소한의 코드로 테스트 통과시키기

컴파일 에러를 해결하기 위해 필요한 최소한의 코드를 작성한다. Kent Beck은 네 가지 컴파일 에러를 하나씩 해결한다:

1. `Dollar` 클래스가 없다 → 클래스 생성
2. 생성자가 없다 → 생성자 추가
3. `times(int)` 메서드가 없다 → 메서드 추가
4. `amount` 필드가 없다 → 필드 추가

```java
class Dollar {
    int amount;

    Dollar(int amount) {
    }

    void times(int multiplier) {
    }
}
```

이제 컴파일은 되지만, 테스트는 **실패**한다. `amount`가 0이기 때문이다 (기대값은 10).

테스트를 통과시키는 가장 빠른 방법은 무엇인가? Kent Beck은 **가장 단순한 방법**을 택한다:

```java
class Dollar {
    int amount = 10;  // 하드코딩!

    Dollar(int amount) {
    }

    void times(int multiplier) {
    }
}
```

**테스트가 통과한다!** Green Bar다.

"잠깐, `amount = 10`이라니? 이건 속임수 아닌가?"

맞다. 이것은 속임수다. 하지만 이것이 TDD의 핵심 전략 중 하나인 **Fake It(가짜로 만들기)** 이다. 먼저 테스트를 통과시키고, 그 다음에 올바른 구현으로 진화시킨다.

### 2.3 Refactor — 중복 제거

Green Bar를 얻었으니, 이제 중복을 제거할 차례다. 어디에 중복이 있는가?

`amount = 10`에서 10은 어디서 왔는가? `5 × 2`에서 왔다. 즉:

```java
// 테스트에 있는 지식:   5 × 2 = 10
// 코드에 있는 지식:     amount = 10
// 중복! 10이라는 값이 두 곳에 있다
```

이 중복을 단계적으로 제거한다:

**Step 1**: 10을 `5 × 2`로 바꾼다

```java
class Dollar {
    int amount = 5 * 2;  // 10 대신 5 * 2
    // ...
}
```

**Step 2**: 5는 생성자에서 받은 값이다

```java
class Dollar {
    int amount;

    Dollar(int amount) {
        this.amount = amount;
    }

    void times(int multiplier) {
        amount *= multiplier;  // 5 * 2를 일반화
    }
}
```

이제 `amount = 10`이라는 하드코딩된 값은 사라지고, 테스트의 지식(`5`, `2`)과 코드의 로직(`amount *= multiplier`)이 분리되었다. **중복이 제거되었다.**

> **핵심 통찰**: TDD에서 "중복 제거"는 단순히 같은 코드가 반복되는 것만을 의미하지 않는다. **테스트와 코드 사이의 데이터 중복**도 중복이다. 테스트가 10을 기대하고 코드가 10을 반환하면, 그 10은 중복이다. 이 중복을 제거하면 일반적인 코드가 만들어진다.

---

## 3. TDD의 리듬과 절차

이 챕터에서 보여준 한 사이클을 정리하면:

### 3.1 Kent Beck이 사용한 절차

1. **작은 테스트를 하나 추가한다** — 전체 문제가 아니라 작은 부분부터
2. **모든 테스트를 실행하고 실패를 확인한다** — 새 테스트가 실패하는지 확인
3. **조금 수정한다** — 최소한의 변경으로 테스트를 통과시킨다
4. **모든 테스트를 실행하고 성공을 확인한다** — Green Bar
5. **중복을 제거하기 위해 리팩토링한다** — 설계 개선

### 3.2 이 과정에서의 핵심 결정들

| 결정 | 선택 | 이유 |
|------|------|------|
| 어떤 테스트부터 시작할 것인가? | `$5 × 2 = $10` | 전체 문제보다 작은 단위가 다루기 쉬움 |
| 테스트를 어떻게 통과시킬 것인가? | Fake It (하드코딩) | 가장 빠르게 Green Bar를 얻을 수 있음 |
| 리팩토링에서 무엇을 할 것인가? | 테스트-코드 간 데이터 중복 제거 | 중복 제거가 일반적 구현으로 이어짐 |

---

## 4. "Fake It" 전략의 의미

이 챕터에서 가장 논쟁적인 부분은 `amount = 10`이라는 하드코딩이다. 왜 이렇게 하는가?

### 4.1 심리적 효과

Green Bar를 빨리 보면 **확신**이 생긴다. "나는 올바른 방향으로 가고 있다"는 확인을 받은 상태에서 다음 단계로 나아갈 수 있다. 반면 처음부터 완벽한 구현을 작성하려 하면, 길을 잃거나 버그를 만들 위험이 높아진다.

### 4.2 설계적 효과

Fake It에서 시작하여 중복을 제거하면, **테스트가 구현을 이끌어낸다(drive)**. 구현이 테스트에서 자연스럽게 파생되므로, 테스트가 검증하지 않는 불필요한 코드를 작성하지 않게 된다.

### 4.3 실무적 판단

Kent Beck은 두 가지 Green Bar 전략을 제시한다:

- **Fake It**: 상수로 시작하여 점진적으로 변수로 대체한다. 구현 방법이 불확실할 때 사용한다.
- **Obvious Implementation**: 올바른 구현이 명백하면 바로 작성한다. 확신이 있을 때 사용한다.

이 챕터에서는 Fake It을 사용했지만, `amount *= multiplier`라는 최종 코드가 "명백한 구현"이었다면 바로 작성해도 된다. 핵심은 **자신의 확신 수준에 맞는 단계 크기를 선택**하는 것이다.

> **핵심 통찰**: Obvious Implementation을 시도했는데 Red Bar가 계속된다면 — 예상치 못한 실패가 연속된다면 — 그것은 Fake It으로 전환하라는 신호다. 큰 걸음이 잘 안 되면 작은 걸음으로 돌아간다.

---

## 5. 이 챕터에서 완성된 코드

```java
// Dollar.java
class Dollar {
    int amount;

    Dollar(int amount) {
        this.amount = amount;
    }

    void times(int multiplier) {
        amount *= multiplier;
    }
}
```

```java
// DollarTest.java
public void testMultiplication() {
    Dollar five = new Dollar(5);
    five.times(2);
    assertEquals(10, five.amount);
}
```

---

## TODO 리스트 (챕터 종료 시점)

- [ ] $5 + 10 CHF = $10 (환율이 2:1인 경우)
- [x] ~~$5 × 2 = $10~~
- [ ] amount를 private으로 만들기
- [ ] Dollar 부작용(side effect)?
- [ ] Money 반올림?

`$5 × 2 = $10`이 완료되었다. 하지만 `Dollar 부작용?`이 아직 남아 있다. `five.times(2)`를 호출하면 `five` 객체의 `amount`가 변경된다. 이것은 다음 챕터에서 다룬다.

---

## 요약

- TDD는 **실패하는 테스트 작성 → 최소한의 코드로 통과 → 중복 제거** 의 사이클로 진행된다.
- 전체 문제를 한 번에 풀려 하지 않는다. **작은 테스트 하나**에서 시작한다.
- 해야 할 일은 **TODO 리스트**에 적어 추적한다. 현재 작업에 집중하기 위해 다른 문제는 리스트에만 적어두고 나중에 처리한다.
- **Fake It** 전략: 상수를 반환하여 테스트를 통과시킨 후, 중복 제거를 통해 일반적인 구현으로 진화시킨다.
- 테스트와 코드 사이의 **데이터 중복**을 제거하면 올바른 구현이 자연스럽게 도출된다.
- 자신감이 있으면 **Obvious Implementation**, 불확실하면 **Fake It** — 상황에 맞는 단계 크기를 선택한다.

---

## 다른 챕터와의 관계

- **Chapter 2 (Degenerate Objects)**: 이 챕터에서 TODO에 남긴 "Dollar 부작용" 문제를 해결한다. `times()` 호출 시 객체가 변이되는 문제를 값 객체(Value Object) 패턴으로 해결한다.
- **Chapter 3 (Equality for All)**: 값 객체를 사용하려면 동등성(equality) 비교가 필요하다. `equals()` 메서드를 TDD로 구현한다.
- **Chapter 12 (Addition, Finally)**: TODO 리스트의 첫 항목인 `$5 + 10 CHF = $10`을 드디어 다룬다. 이 챕터에서 시작된 여정이 Chapter 12에서 꽃을 피운다.
- **Chapter 25 (TDD Patterns)**: 이 챕터에서 사용한 Fake It, Obvious Implementation 전략이 Part III에서 명시적인 패턴으로 정리된다.
- **Chapter 26 (Red Bar Patterns)**: "어떤 테스트를 먼저 작성할 것인가?"에 대한 체계적인 지침을 제공한다.
