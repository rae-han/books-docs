# Chapter 26: Red Bar Patterns (Red Bar 패턴)

## 핵심 질문

실패하는 테스트(Red Bar)를 어떻게 작성해야 하는가? 테스트 목록에서 다음에 작성할 테스트를 어떻게 선택하는가? 테스트를 작성하다 막히면 어떻게 해야 하는가?

---

## 1. 이 챕터의 위치와 역할

TDD의 Red-Green-Refactor 사이클에서, 이 챕터는 **Red 단계** — 실패하는 테스트를 작성하는 과정에 관한 패턴을 다룬다. Chapter 25가 "TDD를 어떻게 실천하는가?"라는 메타-패턴이었다면, Chapter 26은 "어떤 테스트를 어떤 순서로 작성하는가?"라는 더 구체적인 질문에 답한다.

이 챕터에서 다루는 9개 패턴:

| 패턴 | 핵심 질문 |
|------|----------|
| One Step Test | 다음에 어떤 테스트를 작성할 것인가? |
| Starter Test | 첫 번째 테스트는 무엇이어야 하는가? |
| Explanation Test | TDD를 다른 사람에게 어떻게 전파하는가? |
| Learning Test | 새로운 라이브러리/API를 어떻게 학습하는가? |
| Another Test | 작업 중 다른 아이디어가 떠오르면 어떻게 하는가? |
| Regression Test | 버그가 보고되면 어떻게 처리하는가? |
| Break | 막혔을 때 어떻게 하는가? |
| Do Over | 코드가 엉망이 되면 어떻게 하는가? |
| Cheap Desk, Nice Chair | 프로그래밍 생산성을 위해 무엇에 투자해야 하는가? |

---

## 2. One Step Test (한 걸음 테스트)

### 문제

테스트 목록(Test List)에 여러 항목이 있다. 다음에 어떤 테스트를 작성해야 하는가?

### 패턴

**목록에서 다음 조건을 만족하는 테스트를 선택한다: (1) 무언가를 배울 수 있고, (2) 구현할 수 있다는 확신이 있는 테스트.**

### 설명

테스트 선택은 두 축 사이의 균형이다:

```
쉬운 테스트 ←────────────────→ 어려운 테스트
  (배울 것이 없다)                (구현할 수 없다)
                    ↑
              여기가 "한 걸음"
            (배움이 있고, 구현 가능)
```

- 너무 쉬운 테스트를 선택하면 진행이 느려진다 — 이미 아는 것을 반복할 뿐이다
- 너무 어려운 테스트를 선택하면 막힌다 — Red Bar에서 벗어나지 못한다
- **"한 걸음"**만큼의 테스트를 선택한다 — 현재 코드에서 한 단계만 확장하면 구현할 수 있는 테스트

### Part I에서의 예시

Part I에서 Kent Beck의 테스트 선택 순서를 보면:

1. **Chapter 1**: `$5 × 2 = $10` — 곱하기는 더하기보다 쉽다. 다중 통화 더하기(`$5 + 10 CHF`)는 첫 테스트로 너무 크다.
2. **Chapter 3**: `equals()` — 값 객체의 동등성은 `times()`가 동작하는 상태에서 자연스러운 다음 단계다.
3. **Chapter 5**: `Franc` — Dollar가 동작하니, 같은 구조로 다른 통화를 추가할 수 있다.
4. **Chapter 12**: `$5 + 10 CHF = $10` — 단일 통화 연산이 모두 동작한 후에야 다중 통화 더하기에 도전한다.

이 순서를 보면, Kent Beck은 항상 **"지금 있는 코드에서 한 걸음만 더"** 나아가는 테스트를 선택했다. `$5 + 10 CHF`라는 최종 목표를 향해 곧장 달려가지 않고, 작은 단계를 밟아 점진적으로 접근했다.

> **핵심 통찰**: 좋은 테스트 선택은 등산과 같다. 정상(최종 목표)을 바라보되, 발은 현재 위치에서 한 걸음만 옮긴다. 한 번에 절벽을 오르려 하면 떨어진다. TDD의 힘은 이 **작은 단계의 누적**에서 나온다.

---

## 3. Starter Test (시작 테스트)

### 문제

새로운 기능을 구현하기 시작할 때, 첫 번째 테스트는 무엇이어야 하는가?

### 패턴

**가장 단순한 변형(variant)을 테스트하는 것으로 시작한다.** 출력이 입력과 같거나, 비어 있거나, 가장 퇴화된(degenerate) 경우를 먼저 테스트한다.

### 설명

첫 번째 테스트에서 복잡한 시나리오를 다루면, Green Bar를 얻기까지 너무 많은 코드를 작성해야 한다. 대신 **"이 기능이 아무것도 하지 않을 때"** 또는 **"가장 단순한 입력일 때"**를 먼저 테스트한다.

Starter Test의 후보들:

- **빈 컬렉션**: 리스트가 비어 있을 때의 동작
- **아무 연산도 하지 않는 경우**: `0 × anything = 0`
- **입력과 출력이 같은 경우**: 변환 없이 그대로 반환

### 예시: 리스트 정렬 구현

정렬 알고리즘을 TDD로 구현한다고 하자. 첫 테스트로 무엇을 선택해야 하는가?

```java
// 나쁜 시작 — 첫 테스트가 너무 복잡
public void testSort() {
    int[] input = {5, 3, 8, 1, 9, 2, 7};
    int[] result = sort(input);
    assertEquals(new int[]{1, 2, 3, 5, 7, 8, 9}, result);
}
// 이 테스트를 통과시키려면 완전한 정렬 알고리즘이 필요!
```

```java
// 좋은 시작 — 가장 퇴화된 경우부터
public void testSortEmpty() {
    int[] result = sort(new int[]{});
    assertEquals(0, result.length);
}
// 빈 배열은 빈 배열을 반환하면 된다 — 즉시 Green!

public void testSortOneElement() {
    int[] result = sort(new int[]{1});
    assertArrayEquals(new int[]{1}, result);
}
// 원소 하나는 정렬할 필요 없다 — 그대로 반환

public void testSortTwoElements() {
    int[] result = sort(new int[]{2, 1});
    assertArrayEquals(new int[]{1, 2}, result);
}
// 이제야 실제 정렬 로직이 필요하다 — 하지만 2개뿐이므로 간단
```

### Part I에서의 예시

Part I Chapter 1에서 Kent Beck은 `$5 + 10 CHF = $10`(다중 통화 더하기) 대신 `$5 × 2 = $10`(단일 통화 곱하기)로 시작했다. 이것이 바로 Starter Test 패턴이다. 곱하기는 더하기보다 단순하고, 단일 통화는 다중 통화보다 단순하다.

> **핵심 통찰**: Starter Test는 "처음의 관성"을 극복하는 도구다. 빈 화면 앞에서 "뭘 먼저 해야 하지?"라는 고민이 들 때, "가장 단순한 경우는 뭐지?"라고 자문하면 시작점이 보인다. 첫 Green Bar를 빨리 얻으면, 그 모멘텀이 다음 단계를 쉽게 만든다.

---

## 4. Explanation Test (설명 테스트)

### 문제

TDD를 실천하지 않는 팀원에게 TDD의 가치를 어떻게 전달하는가?

### 패턴

**테스트를 사용하여 코드의 동작을 설명한다.** "이 코드가 이렇게 동작해야 한다"는 것을 말로 설명하는 대신 테스트로 보여준다. 다른 사람이 코드의 동작을 물으면, "제가 테스트를 작성해서 보여드릴게요"라고 답한다.

### 설명

Kent Beck은 TDD를 전파하는 가장 효과적인 방법이 **시연**이라고 말한다. 이론적인 장점을 설명하는 것보다, 실제로 테스트를 작성하여 문제를 해결하는 모습을 보여주는 것이 훨씬 설득력 있다.

실전에서의 활용:

```
팀원: "이 함수에 null을 넣으면 어떻게 되나요?"
당신: "테스트를 작성해서 확인해보죠."

팀원: "이 리팩토링이 기존 동작을 깨뜨리지 않을까요?"
당신: "테스트를 실행해보면 알 수 있습니다."

팀원: "이 API는 어떻게 사용하는 건가요?"
당신: "테스트 코드를 보시면 사용 예가 나와 있습니다."
```

Explanation Test는 TDD의 **사회적 측면**을 다루는 패턴이다. 기술적으로 완벽한 TDD를 혼자 실천하는 것보다, 팀 전체가 TDD를 채택하는 것이 훨씬 효과적이다. 그리고 그 채택은 강제가 아니라 시연과 초대로 이루어져야 한다.

> **핵심 통찰**: TDD의 전파는 "설득"이 아니라 "시연"으로 한다. "TDD가 좋습니다"라고 말하지 말고, "이 문제를 테스트로 풀어보겠습니다"라고 행동으로 보여준다. 테스트가 버그를 잡는 순간, 회의적이던 팀원도 관심을 갖게 된다.

---

## 5. Learning Test (학습 테스트)

### 문제

새로운 서드파티 라이브러리나 API를 처음 사용할 때, 문서만 읽어서는 동작 방식을 확신할 수 없다. 어떻게 학습하는가?

### 패턴

**서드파티 코드의 동작을 검증하는 테스트를 작성한다.** 이 테스트는 자신의 코드가 아니라 남의 코드를 테스트하는 것이지만, 그 목적은 "이 라이브러리가 내 이해대로 동작하는가?"를 확인하는 것이다.

### 설명

Learning Test는 두 가지 이점을 제공한다:

1. **학습 확인**: "내가 이 API를 올바르게 이해하고 있는가?"를 코드로 검증한다
2. **호환성 경보**: 라이브러리를 업그레이드할 때, Learning Test가 실패하면 동작 변경을 즉시 감지할 수 있다

### 예시: Java의 ArrayList 학습

```java
// ArrayList의 동작을 학습하기 위한 테스트
public void testArrayListGrowth() {
    ArrayList<String> list = new ArrayList<>();
    assertTrue(list.isEmpty());

    list.add("first");
    assertEquals(1, list.size());
    assertEquals("first", list.get(0));

    list.add("second");
    assertEquals(2, list.size());
}

public void testArrayListRemoval() {
    ArrayList<String> list = new ArrayList<>();
    list.add("a");
    list.add("b");
    list.add("c");

    list.remove(1);  // 인덱스 1의 요소 제거
    assertEquals(2, list.size());
    assertEquals("a", list.get(0));
    assertEquals("c", list.get(1));  // "c"가 인덱스 1로 이동했는가?
}
```

이 테스트들은 `ArrayList`에 대한 자신의 이해를 코드로 표현한 것이다. `remove(1)` 후에 나머지 요소가 앞으로 당겨지는지를 **추측이 아니라 실행으로** 확인한다.

### 실무 활용

```java
// JSON 파싱 라이브러리의 동작 학습
public void testJacksonNullHandling() {
    ObjectMapper mapper = new ObjectMapper();
    String json = "{\"name\": null}";
    Person person = mapper.readValue(json, Person.class);
    assertNull(person.getName());  // null이 그대로 전달되는가?
}

public void testJacksonMissingField() {
    ObjectMapper mapper = new ObjectMapper();
    String json = "{}";  // name 필드가 없음
    Person person = mapper.readValue(json, Person.class);
    assertNull(person.getName());  // 필드가 없으면 null인가?
}
```

> **핵심 통찰**: Learning Test는 "문서 읽기"의 TDD 버전이다. API 문서를 읽는 대신 테스트를 작성하면, 이해가 정확한지 즉시 피드백을 받을 수 있다. 또한 라이브러리 업그레이드 시 "기존에 의존하던 동작이 바뀌었는가?"를 자동으로 감지하는 경보 시스템이 된다.

---

## 6. Another Test (또 다른 테스트)

### 문제

하나의 테스트를 구현하는 도중에, 다른 테스트에 대한 아이디어가 떠오른다. 지금 하던 것을 멈추고 새 아이디어를 추구해야 하는가?

### 패턴

**새 아이디어를 테스트 목록에 추가하고, 현재 작업을 계속한다.** 지금 하고 있는 테스트를 완성하는 것이 우선이다.

### 설명

프로그래밍 중에는 끊임없이 새로운 아이디어가 떠오른다:

```
현재 작업: $5 × 2 = $10 구현 중
  ↓ 떠오르는 생각들:
  → "null을 곱하면 어떻게 되지?"
  → "음수를 곱하면?"
  → "overflow가 발생하면?"
  → "equals()도 구현해야 하지 않나?"
  → "toString()도 있으면 디버깅이 편하겠다"
```

이 모든 생각을 즉시 추구하면 **산만함의 늪**에 빠진다. Another Test 패턴은 간단하다:

1. 아이디어를 **테스트 목록에 한 줄로 적는다**
2. 현재 테스트로 **즉시 돌아간다**
3. 현재 테스트가 Green이 되면, 목록에서 다음 항목을 선택한다

### Part I에서의 예시

Part I 전체에서 Kent Beck은 이 패턴을 반복적으로 사용했다. Chapter 1에서 `$5 × 2 = $10`을 구현하면서도 "amount를 private으로 만들기", "Dollar 부작용?", "Money 반올림?" 등의 아이디어를 TODO 리스트에 적어두고 현재 작업에 집중했다.

> **핵심 통찰**: Another Test는 **주의력 관리** 패턴이다. 인간의 작업 기억(working memory)은 제한적이다. 여러 문제를 동시에 해결하려 하면 모든 문제의 해결 품질이 떨어진다. 아이디어를 목록에 적는 행위는 "뇌에서 종이로 책임을 이전"하는 것이며, 이것이 집중력을 되찾게 해준다.

---

## 7. Regression Test (회귀 테스트)

### 문제

운영 중인 시스템에서 버그가 보고되었다. 어떻게 수정해야 하는가?

### 패턴

**버그를 수정하기 전에, 그 버그를 재현하는 테스트를 먼저 작성한다.** 이 테스트가 실패하는 것을 확인한 후(Red), 버그를 수정하여 테스트를 통과시킨다(Green).

### 설명

Regression Test의 절차:

1. **버그 보고를 받는다**: "환율 변환에서 소수점 이하가 잘린다"
2. **재현 테스트를 작성한다**: 버그를 발생시키는 최소한의 테스트 케이스
3. **테스트 실패를 확인한다**: Red Bar — 버그가 재현됨을 증명
4. **버그를 수정한다**: Green Bar — 버그가 수정됨을 증명
5. **테스트를 영구 보관한다**: 같은 버그가 다시 발생하면 이 테스트가 잡아낸다

```java
// Step 1: 버그 보고 — "1.33 CHF를 USD로 변환하면 0 USD가 된다"

// Step 2: 재현 테스트
public void testFractionalConversion() {
    Bank bank = new Bank();
    bank.addRate("CHF", "USD", 1.5);
    Money result = bank.reduce(Money.franc(1.33), "USD");
    // 1.33 / 1.5 = 0.8866...
    assertEquals(Money.dollar(0.89), result);  // 반올림
}

// Step 3: 이 테스트가 실패하면, 버그가 재현된 것이다

// Step 4: 변환 로직에서 소수점 처리를 수정한다

// Step 5: 이 테스트는 영구적으로 테스트 스위트에 남는다
```

### Regression Test의 의미

Regression Test는 두 가지 질문에 답한다:

- **"이 버그의 원인은 무엇인가?"** → 테스트를 작성하면서 버그의 정확한 조건을 파악하게 된다
- **"이 버그가 다시 발생하면 어떻게 감지하는가?"** → 테스트가 영구적인 경보 장치가 된다

| 테스트 없이 버그 수정 | Regression Test와 함께 버그 수정 |
|---------------------|-------------------------------|
| 버그를 수정하고 수동으로 확인 | 먼저 테스트를 작성하고, 테스트 통과로 확인 |
| 같은 버그가 재발할 수 있음 | 재발 시 테스트가 즉시 감지 |
| 수정이 다른 곳을 깨뜨릴 수 있음 | 전체 테스트 실행으로 부작용 감지 |

> **핵심 통찰**: Regression Test는 "실수에서 배우는" 패턴이다. 버그가 발견되었다는 것은 테스트 스위트에 구멍이 있다는 의미이며, Regression Test는 그 구멍을 메운다. 모든 버그를 한 번만 경험하게 만드는 것이 목표다. Kent Beck은 이렇게 말한다: "회귀 테스트를 작성해야 한다는 것은, 처음부터 테스트가 빠져 있었다는 신호다."

---

## 8. Break (휴식)

### 문제

프로그래밍 중에 완전히 막혔다. 테스트를 어떻게 통과시킬지 모르겠고, 생각이 나지 않는다. 어떻게 해야 하는가?

### 패턴

**휴식을 취한다.** 산책을 하거나, 커피를 마시거나, 낮잠을 자거나, 다음 날로 미룬다.

### 설명

이것은 놀라울 정도로 실용적인 패턴이다. Kent Beck은 다음과 같이 설명한다:

- 피곤한 상태에서 짜낸 코드는 대개 나쁘다
- 무의식이 문제를 처리하는 데 시간이 필요할 때가 있다
- 강제로 해결하려 하면 "좋은 해결책" 대신 "되기만 하는 해결책"이 나온다

TDD는 이 패턴을 특히 잘 지원한다. 왜냐하면:

1. **Red Bar가 남아 있다** → "어디서 멈췄는지"가 명확하다. 돌아왔을 때 테스트를 실행하면 바로 현재 상태를 파악할 수 있다.
2. **기존 테스트가 안전망이다** → 휴식 후 다시 시작할 때, 기존 코드가 여전히 동작하는지 테스트로 확인할 수 있다.

Kent Beck은 짝 프로그래밍(pair programming)에서도 이 원칙을 적용한다. 파트너에게 "5분만 쉬겠습니다"라고 말할 수 있어야 하며, 돌아왔을 때 Red Bar가 현재 상태를 알려준다.

> **핵심 통찰**: Break는 "나약함"이 아니라 **생산성 전략**이다. 막혔을 때 30분을 억지로 투자하는 것보다, 15분 쉬고 5분 만에 해결하는 것이 더 효율적이다. TDD의 Red Bar는 이 휴식을 안전하게 만들어준다 — "어디까지 했지?"를 기억할 필요 없이, 테스트를 실행하면 된다.

---

## 9. Do Over (처음부터 다시)

### 문제

코드가 완전히 엉망이 되었다. 리팩토링으로는 구제할 수 없을 것 같다. 어떻게 해야 하는가?

### 패턴

**코드를 버리고 처음부터 다시 시작한다.**

### 설명

"내가 작성한 코드를 버린다"는 것은 대부분의 프로그래머에게 심리적으로 어려운 일이다. 하지만 Kent Beck은 다음과 같이 주장한다:

- 엉망인 코드 위에 쌓으면 더 엉망이 된다
- 두 번째로 작성하는 코드는 항상 첫 번째보다 낫다 (이미 문제를 이해하고 있으므로)
- TDD를 사용하면 **테스트는 보존된다** — 코드만 버리고 테스트는 남긴다

Do Over의 절차:

1. **테스트를 보존한다** — 테스트는 요구사항의 표현이므로 버리지 않는다
2. **구현 코드를 삭제한다**
3. **테스트를 하나씩 다시 통과시킨다** — 이번에는 더 나은 설계로

TDD에서 Do Over가 덜 고통스러운 이유:

| TDD 없이 Do Over | TDD와 함께 Do Over |
|------------------|-------------------|
| 요구사항을 다시 파악해야 한다 | 테스트가 요구사항을 표현한다 |
| 처음부터 모든 것을 다시 구현 | 테스트를 가이드로 삼아 구현 |
| "잘 되고 있나?" 확인이 어렵다 | Green Bar가 진행 상황을 알려준다 |
| 기존의 실수를 반복할 수 있다 | 기존 실수가 테스트로 잡힌다 |

> **핵심 통찰**: Do Over는 **용기의 패턴**이다. "매몰 비용의 오류(sunk cost fallacy)"에 빠지지 않는 것이 중요하다. 4시간 동안 작성한 코드가 구조적으로 잘못되었다면, 그 4시간에 집착하여 40시간을 더 낭비하는 것보다 4시간을 포기하고 다시 시작하는 것이 현명하다. TDD는 테스트라는 안전망을 제공하여 이 결정을 덜 무섭게 만든다.

---

## 10. Cheap Desk, Nice Chair (싸구려 책상, 좋은 의자)

### 문제

프로그래밍 생산성을 높이기 위해 무엇에 투자해야 하는가?

### 패턴

**프로그래밍에 실질적으로 영향을 미치는 것에 투자하고, 그렇지 않은 것에는 절약한다.**

### 설명

이것은 코드 패턴이 아니라 **환경 패턴**이다. Kent Beck이 제목으로 든 비유:

- **싸구려 책상(Cheap Desk)**: 책상의 가격은 프로그래밍 품질에 영향을 주지 않는다
- **좋은 의자(Nice Chair)**: 하루 8시간 이상 앉아 있는 의자는 건강과 집중력에 직접적 영향을 준다

이 비유를 확장하면:

| 투자할 가치가 높은 것 | 투자할 가치가 낮은 것 |
|----------------------|---------------------|
| 좋은 모니터 (눈의 피로 감소) | 화려한 키보드 조명 |
| 빠른 테스트 실행 환경 | 최신 장식품 |
| 편안한 의자 | 비싼 책상 |
| 충분한 메모리 | 불필요하게 높은 사양의 GPU |
| 지속적 통합(CI) 시스템 | 복잡한 개발 도구 |

Kent Beck의 핵심 메시지는, TDD에서 **피드백 루프의 속도**가 가장 중요한 투자 대상이라는 것이다. 테스트를 실행하는 데 10초가 걸리면 자주 실행하지만, 10분이 걸리면 실행을 미루게 된다. TDD의 리듬을 유지하려면 테스트 실행이 빨라야 한다.

> **핵심 통찰**: 프로그래밍 생산성은 도구의 가격이 아니라 **피드백 속도**에 비례한다. Red-Green-Refactor 사이클을 빠르게 돌릴 수 있는 환경을 만드는 것이 가장 중요한 투자다. 테스트가 1초 만에 실행되는 환경과 1분이 걸리는 환경에서의 TDD 경험은 완전히 다르다.

---

## 요약

- **One Step Test**: 테스트 목록에서 "배울 것이 있고, 구현할 수 있는" 테스트를 선택한다. 현재 코드에서 한 걸음만 더 나아가는 테스트가 적절하다.
- **Starter Test**: 첫 테스트는 가장 단순한 변형(빈 컬렉션, 퇴화 입력 등)으로 시작한다. 빠른 Green Bar가 모멘텀을 만든다.
- **Explanation Test**: 테스트를 사용하여 코드의 동작을 설명하고, TDD를 시연으로 전파한다.
- **Learning Test**: 서드파티 코드의 동작을 검증하는 테스트를 작성하여, 이해를 확인하고 라이브러리 업그레이드 시 호환성을 감시한다.
- **Another Test**: 작업 중 떠오르는 아이디어는 테스트 목록에 적고 현재 작업에 집중한다. 산만함을 방지한다.
- **Regression Test**: 버그를 수정하기 전에 재현 테스트를 먼저 작성한다. 같은 버그가 두 번 발생하지 않도록 한다.
- **Break**: 막혔을 때 휴식을 취한다. Red Bar가 중단 지점을 기억해주므로 안심하고 쉴 수 있다.
- **Do Over**: 코드가 구제 불능이면 버리고 처음부터 다시 한다. 테스트는 보존하여 가이드로 삼는다.
- **Cheap Desk, Nice Chair**: 피드백 루프 속도에 투자한다. 빠른 테스트 실행이 TDD의 리듬을 유지하는 핵심이다.

---

## 다른 챕터와의 관계

- **Chapter 25 (TDD Patterns)**: Test List 패턴이 이 챕터의 One Step Test, Another Test와 직접 연결된다. Test List에서 어떤 항목을 선택하느냐가 이 챕터의 주제다.
- **Chapter 1 (Multi-Currency Money)**: Starter Test의 실례다 — `$5 + 10 CHF` 대신 `$5 × 2`로 시작했다. One Step Test의 실례이기도 하다.
- **Chapter 27 (Testing Patterns)**: Red Bar를 만들기 위한 전략(이 챕터)과, 더 나은 테스트를 작성하는 기법(Chapter 27)이 상호 보완한다.
- **Chapter 28 (Green Bar Patterns)**: 이 챕터가 "어떤 테스트를 작성할 것인가?"를 다룬다면, Chapter 28은 "그 테스트를 어떻게 통과시킬 것인가?"를 다룬다. Red와 Green은 동전의 양면이다.
- **Chapter 17 (Money Retrospective)**: Part I 전체를 돌아보며, 테스트 선택 순서와 TDD 리듬에 대한 회고를 제공한다. 이 챕터의 패턴들이 실전에서 어떻게 작동했는지를 보여준다.
