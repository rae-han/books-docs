# Chapter 32: Mastering TDD (TDD 마스터하기)

## 핵심 질문

TDD를 실무에 적용할 때 마주치는 실질적인 질문들에 대한 답은 무엇이며, TDD의 궁극적인 가치는 어디에 있는가?

---

## 1. 개요

이 챕터는 이 책의 마지막 챕터다. Part I에서 다중 통화 시스템을, Part II에서 테스트 프레임워크를 TDD로 구현했고, Part III에서 그 과정에서 사용한 패턴들을 정리했다. 이제 남은 것은 실전에서 마주치는 질문들에 답하는 것이다.

Kent Beck은 이 챕터를 FAQ 형식으로 구성한다. TDD를 처음 시작하거나 실천하다 부딪히는 의문들 — "단계의 크기는 얼마나 작아야 하는가?", "무엇을 테스트해야 하는가?", "언제 테스트를 삭제하는가?" 등 — 에 자신의 경험과 철학을 바탕으로 대답한다.

---

## 2. 단계의 크기는 얼마나 작아야 하는가?

### 2.1 Kent Beck의 답

**자신감에 따라 조절한다.** 확신이 있을 때는 큰 걸음으로, 불확실할 때는 작은 걸음으로 진행한다. 핵심은 **언제든 작은 걸음으로 돌아갈 수 있어야 한다**는 것이다.

### 2.2 구체적 기준

| 상황 | 권장 단계 크기 | 예시 |
|------|---------------|------|
| 구현이 명백할 때 | 큰 단계: 바로 올바른 구현 작성 | Obvious Implementation |
| 약간 불확실할 때 | 중간 단계: Fake It 후 점진적 일반화 | 상수 반환 → 변수로 대체 |
| 매우 불확실할 때 | 작은 단계: 한 번에 한 가지만 변경 | Triangulation |
| 실패가 발생했을 때 | 더 작은 단계로 후퇴 | 마지막 성공 상태로 되돌리고 재시도 |

### 2.3 실전 예시

```java
// 큰 단계 — 구현이 명백할 때
public void testSum() {
    assertEquals(5, add(2, 3));
}
// 바로 올바른 구현
int add(int a, int b) {
    return a + b;
}

// 작은 단계 — 불확실할 때
public void testFibonacci() {
    assertEquals(0, fib(0));
}
// Fake It
int fib(int n) {
    return 0;  // 상수 반환
}

public void testFibonacci1() {
    assertEquals(1, fib(1));
}
// 한 단계 진전
int fib(int n) {
    if (n == 0) return 0;
    return 1;
}

public void testFibonacci2() {
    assertEquals(1, fib(2));
}
// 여전히 통과 — 다음 테스트가 필요

public void testFibonacci3() {
    assertEquals(2, fib(3));
}
// 이제 일반화
int fib(int n) {
    if (n <= 1) return n;
    return fib(n - 1) + fib(n - 2);
}
```

Part I에서도 이 원칙이 일관되게 적용되었다. 처음에는 `Dollar.times()`에 상수를 반환하는 것부터 시작했다(Chapter 1). 이것이 놀라울 정도로 작은 단계였지만, 그 작은 단계가 안전한 진행을 보장했다.

> **핵심 통찰**: "올바른" 단계 크기는 없다. 단계 크기는 고정된 것이 아니라 **자신감의 함수**다. 같은 프로그래머라도 상황에 따라 다른 크기의 단계를 밟는다. 문제가 생기면 항상 더 작은 단계로 돌아갈 수 있다는 것이 TDD의 안전망이다.

---

## 3. 무엇을 테스트하지 않아도 되는가?

### 3.1 Kent Beck의 원칙

**"깨질 수 있는 모든 것을 테스트하라(Test everything that could possibly break)."** 그런데 이 원칙을 뒤집으면 "깨질 수 없는 것은 테스트하지 않아도 된다"가 된다.

### 3.2 테스트하지 않아도 되는 것들

| 항목 | 이유 |
|------|------|
| **프레임워크 코드** | 이미 프레임워크 개발자가 테스트했다. Java의 `ArrayList`나 Spring의 `@Autowired`를 테스트할 필요 없다 |
| **단순 getter/setter** | `getAmount()` / `setAmount()`처럼 로직이 없는 메서드는 깨질 가능성이 거의 없다 |
| **자동 생성 코드** | IDE나 도구가 생성한 코드는 이미 도구가 보장한다 |
| **타사 라이브러리 내부** | 라이브러리의 내부 동작이 아닌, 내가 사용하는 방식을 테스트한다 |

### 3.3 그렇다면 무엇을 테스트해야 하는가?

- 조건 분기(`if`, `switch`)
- 반복문의 경계 조건
- 다형성에 의한 행위 변화
- 복잡한 계산 로직
- 에러 처리 경로
- 비즈니스 규칙

```java
// 테스트할 필요 없음 — 단순 위임
public String getName() {
    return name;
}

// 테스트해야 함 — 비즈니스 로직
public Money calculateDiscount(Money price, int quantity) {
    if (quantity >= 100) return price.times(0.10);
    if (quantity >= 50) return price.times(0.05);
    return Money.zero();
}
```

> **핵심 통찰**: "무엇을 테스트할 것인가"는 경험에서 오는 판단이다. 초보자라면 "의심스러운 것은 모두 테스트하라." 경험이 쌓이면서 "깨질 수 있는 것"에 대한 직관이 생기고, 테스트의 범위를 적절히 조절할 수 있게 된다. 하지만 의심스러울 때는 **항상 테스트를 추가하는 쪽**으로 결정하라.

---

## 4. 좋은 테스트의 기준은 무엇인가?

### 4.1 Kent Beck의 답

좋은 테스트는 **행위 변경에 민감하고(sensitive to behavior changes), 구조 변경에 둔감하다(insensitive to structure changes).**

### 4.2 구체적인 품질 기준

| 품질 | 설명 | 예 |
|------|------|-----|
| **행위 민감성** | 코드의 행위가 바뀌면 테스트가 실패해야 한다 | 할인 로직이 변경되면 할인 테스트가 실패 |
| **구조 둔감성** | 내부 구조를 바꿔도 테스트가 통과해야 한다 | 클래스 분리/병합 시 테스트 변경 불필요 |
| **빠른 실행** | 테스트가 빨라야 자주 실행한다 | 전체 테스트 스위트가 수 초 내에 완료 |
| **독립성** | 테스트 순서에 무관하게 동일한 결과 | 테스트 A의 성공/실패가 테스트 B에 영향 없음 |
| **가독성** | 테스트가 무엇을 검증하는지 쉽게 이해 가능 | 이름과 구조만 보고 의도 파악 가능 |

### 4.3 나쁜 테스트의 징후

```java
// 나쁜 테스트 — 내부 구조에 의존
public void testOrderTotal() {
    Order order = new Order();
    order.items = new ArrayList<>();  // 내부 필드에 직접 접근
    order.items.add(new Item("book", 1000));
    // items 필드의 타입이 바뀌면 테스트가 깨짐
    assertEquals(1000, order.calculateTotal());
}

// 좋은 테스트 — 공개 행위에 의존
public void testOrderTotal() {
    Order order = new Order();
    order.addItem("book", 1000);  // 공개 API 사용
    assertEquals(1000, order.calculateTotal());
    // 내부 구조가 바뀌어도 이 테스트는 유효
}
```

### 4.4 테스트 냄새(Test Smell)

- **설정이 너무 긴 테스트**: 객체 설계에 문제가 있다는 신호
- **여러 곳이 깨지는 테스트 변경**: 테스트 간 결합도가 높다는 신호
- **실행이 느린 테스트**: 외부 의존성을 격리하지 못했다는 신호
- **깨지지 않는 테스트**: 아무것도 검증하지 않는다는 신호

> **핵심 통찰**: 테스트 코드도 프로덕션 코드만큼 중요하다. 테스트가 유지보수하기 어렵다면, 테스트를 작성하는 것 자체가 부담이 되고, 결국 TDD를 포기하게 된다. "테스트의 테스트"는 프로덕션 코드를 변경했을 때 적절히 실패하는가(행위 민감성)와 리팩토링했을 때 불필요하게 실패하지 않는가(구조 둔감성)로 판단한다.

---

## 5. TDD는 어떻게 프레임워크로 이어지는가?

### 5.1 발견적 접근

TDD에서 프레임워크는 **설계하는 것이 아니라 발견하는 것**이다. 테스트를 작성하고 중복을 제거하다 보면, 재사용 가능한 추상화가 자연스럽게 나타난다.

### 5.2 Part I에서의 진화 과정

```
Dollar (구체 클래스)
    ↓ 중복 발견
Dollar + Franc (두 개의 유사한 클래스)
    ↓ 추상화
Money (공통 상위 클래스)
    ↓ 인터페이스 추출
Expression (추상 인터페이스)
    ↓ 구현체 추가
Money, Sum (Expression 구현)
    ↓ 조합
Bank.reduce(Expression, String) → Money
```

처음에 Kent Beck이 "다중 통화 프레임워크를 만들자"고 시작한 것이 아니다. `$5 * 2 = $10`이라는 단순한 테스트에서 시작하여, 테스트를 추가하고 중복을 제거하다 보니 다중 통화를 지원하는 유연한 구조가 만들어졌다.

### 5.3 Part II에서의 진화 과정

Part II도 마찬가지다. "테스트 프레임워크를 만들자"고 시작한 것이 아니라, "테스트 메서드를 실행할 수 있는가?"라는 단순한 테스트에서 시작했다:

```python
# 시작점 — Chapter 18
test = WasRun("testMethod")
test.run()
assert test.wasRun  # 이것이 전부

# 최종 결과 — Chapter 23
suite = TestSuite()
suite.add(...)
result = TestResult()
suite.run(result)
print(result.summary())  # 완전한 테스트 프레임워크
```

> **핵심 통찰**: "프레임워크를 미리 설계하지 마라. 구체적인 문제를 풀다 보면 프레임워크가 나타난다." 이것이 TDD의 설계 철학이다. 미리 설계한 프레임워크는 실제 사용 패턴과 맞지 않을 위험이 크다. TDD로 구체적인 사례에서 시작하면, 프레임워크가 실제 필요에 정확히 맞춰진다.

---

## 6. 피드백은 얼마나 필요한가?

### 6.1 피드백과 테스트의 관계

TDD에서 테스트는 **피드백 장치**다. 테스트가 많을수록 피드백이 많아지고, 코드에 대한 확신도 커진다. 하지만 무한정 테스트를 늘릴 수는 없다.

### 6.2 수확 체감의 법칙

```
확신 수준
    │
100%│                        ·····················
    │                   ·····
    │              ····
    │         ····
    │     ···
    │   ··
    │  ·
    │ ·
    │·
    └──────────────────────────────────────── 테스트 수
```

처음 몇 개의 테스트는 확신을 크게 높인다. 하지만 일정 수준을 넘어가면, 테스트를 하나 더 추가해도 확신이 크게 늘지 않는다. 그 **적정선**을 찾는 것이 중요하다.

### 6.3 실전 가이드

- **핵심 비즈니스 로직**: 테스트를 풍부하게 작성한다. 여기서의 버그는 비용이 크다.
- **경계 조건**: 0, null, 빈 배열, 최대값 등 특수한 경우를 테스트한다.
- **정상 경로 + 에러 경로**: 성공하는 시나리오와 실패하는 시나리오를 모두 다룬다.
- **단순 CRUD**: 비교적 적은 테스트로 충분할 수 있다.

Kent Beck의 경험 법칙: "테스트를 하나 더 추가했을 때 새로운 것을 배울 수 있는가? 배울 것이 없다면 충분하다."

> **핵심 통찰**: 테스트는 100% 버그를 잡기 위한 것이 아니다. 테스트는 **설계 도구이자 문서이자 안전망**이다. "이 코드가 무엇을 하는지"를 테스트가 설명하고, "코드를 변경해도 괜찮은지"를 테스트가 보장한다. 적정 수준의 테스트는 이 세 역할을 모두 수행할 만큼이다.

---

## 7. 테스트를 삭제해야 할 때는 언제인가?

### 7.1 Kent Beck의 기준

**두 테스트가 같은 것을 테스트하고, 하나를 삭제해도 자신감이 줄지 않는다면 삭제한다.**

### 7.2 구체적 기준

| 삭제 고려 | 유지 |
|-----------|------|
| 두 테스트가 동일한 코드 경로를 검증 | 각 테스트가 다른 코드 경로를 검증 |
| 삭제해도 커버리지가 동일 | 삭제하면 커버리지 감소 |
| 삭제해도 의사소통(documentation) 가치가 줄지 않음 | 삭제하면 "이 코드가 무엇을 하는지" 정보 손실 |

### 7.3 예시

```java
// 이 두 테스트는 중복인가?
public void testMultiplyByTwo() {
    assertEquals(Money.dollar(10), Money.dollar(5).times(2));
}

public void testMultiplyByThree() {
    assertEquals(Money.dollar(15), Money.dollar(5).times(3));
}
```

`times()` 메서드가 `return new Money(amount * multiplier, currency)`처럼 일반적으로 구현되어 있다면, `testMultiplyByTwo`만으로도 충분하다. `testMultiplyByThree`를 삭제해도 자신감이 줄지 않는다.

하지만 다음의 경우는 다르다:

```java
public void testMultiplyByPositive() {
    assertEquals(Money.dollar(10), Money.dollar(5).times(2));
}

public void testMultiplyByZero() {
    assertEquals(Money.dollar(0), Money.dollar(5).times(0));
}

public void testMultiplyByNegative() {
    assertEquals(Money.dollar(-5), Money.dollar(5).times(-1));
}
```

이 세 테스트는 각각 다른 경계 조건을 검증한다. 하나라도 삭제하면 중요한 시나리오가 검증되지 않는다.

### 7.4 두 가지 차원

Kent Beck은 테스트를 두 가지 차원으로 평가한다:

1. **자신감(Confidence)**: 이 테스트가 버그를 잡는 데 기여하는가?
2. **의사소통(Communication)**: 이 테스트가 코드의 행위를 설명하는가?

자신감과 의사소통 중 하나라도 기여한다면 유지한다. 둘 다 기여하지 않는다면 삭제를 고려한다.

> **핵심 통찰**: 테스트를 삭제하는 것은 용기가 필요한 일이다. 하지만 불필요한 테스트는 유지보수 비용을 증가시키고, 리팩토링을 방해할 수 있다. "이 테스트를 삭제하면 불안한가?"를 자문하여 답이 "아니오"라면 삭제해도 좋다.

---

## 8. TDD와 설계 패턴의 관계

### 8.1 상향식 패턴 발견

전통적 설계에서 패턴은 **하향식(top-down)**으로 적용한다. "이 문제에는 Strategy 패턴이 적합하니까, Strategy로 설계하자." TDD에서 패턴은 **상향식(bottom-up)**으로 발견한다. "중복을 제거하다 보니 Strategy 패턴이 나타났다."

### 8.2 Part I에서의 패턴 발견 과정

```
시작: Dollar five = new Dollar(5);
  ↓ 부작용 발견, 불변으로 변경
패턴 발견: Value Object

시작: Dollar와 Franc의 times()가 비슷함
  ↓ 상위 클래스로 통합
패턴 발견: Template Method

시작: new Dollar() 대신 Money.dollar() 사용
  ↓ 구체 클래스 은닉
패턴 발견: Factory Method

시작: $5 + 10CHF를 표현해야 함
  ↓ Money와 Sum을 같은 타입으로
패턴 발견: Composite + Imposter
```

어떤 경우에도 "이 패턴을 적용하겠다"고 미리 결정하지 않았다. 테스트를 작성하고 중복을 제거하는 과정에서 패턴이 **저절로** 나타났다.

### 8.3 패턴 지식의 가치

그렇다고 패턴을 공부할 필요가 없다는 뜻은 아니다. 패턴을 알고 있으면 리팩토링의 목적지를 더 잘 인식할 수 있다. "이 코드에서 조건문을 제거하고 있는데... 이것은 Pluggable Object 패턴을 향해 가고 있구나"하고 방향을 잡을 수 있다.

> **핵심 통찰**: TDD에서 패턴은 "적용하는 것"이 아니라 "나타나는 것"이다. 하지만 패턴을 알고 있으면 나타나는 것을 더 빨리 인식하고, 리팩토링의 방향을 더 잘 잡을 수 있다. 패턴 지식은 TDD의 리팩토링 단계에서 빛을 발한다.

---

## 9. TDD는 왜 효과적인가?

### 9.1 Kent Beck이 제시하는 이유들

**이유 1: 결함 감소**

테스트를 먼저 작성하면, 코드가 완성되는 시점에 이미 상당한 수준의 자동 테스트가 존재한다. 결함이 일찍 발견되어 수정 비용이 낮다.

**이유 2: 설계 피드백**

테스트하기 어려운 코드는 대개 설계가 나쁜 코드다. TDD는 "이 코드를 어떻게 테스트할 것인가?"를 끊임없이 묻게 만들고, 이것이 곧 "이 코드의 설계는 어떠한가?"에 대한 피드백이 된다.

```
테스트 작성이 어렵다
    → 의존성이 너무 많다
    → 의존성을 줄여야 한다
    → 더 나은 설계가 된다
```

**이유 3: 자신감**

Green Bar는 "지금까지 작성한 코드가 올바르게 동작한다"는 신호다. 이 자신감이 과감한 리팩토링을 가능하게 하고, 과감한 리팩토링이 좋은 설계를 만든다.

**이유 4: 문서화**

테스트는 "이 코드가 무엇을 하는가"를 보여주는 **실행 가능한 문서**다. 주석이나 문서와 달리, 테스트는 코드와 함께 실행되므로 항상 최신 상태를 유지한다.

### 9.2 심리적 효과

TDD의 Red → Green → Refactor 사이클은 심리적으로도 효과적이다:

| 단계 | 심리 상태 | 효과 |
|------|----------|------|
| Red | 목표가 명확하다 ("이 테스트를 통과시키자") | 집중력 향상 |
| Green | 성취감 ("테스트가 통과했다!") | 동기 부여 |
| Refactor | 안전감 ("테스트가 지켜주고 있다") | 대담한 개선 가능 |

이 사이클이 빠르게(보통 수 분 이내) 반복되면, 프로그래머는 **지속적인 성취감**을 느낀다. 이것이 "프로그래밍이 즐겁다"는 감각으로 이어진다.

> **핵심 통찰**: TDD의 효과는 기술적 차원(결함 감소, 설계 개선)과 심리적 차원(자신감, 즐거움) 모두에서 나타난다. Kent Beck은 "TDD를 사용하면 코드에 대한 두려움이 줄어든다"고 말한다. 두려움이 줄면 변경에 대한 저항이 줄고, 변경이 쉬워지면 소프트웨어가 더 빨리 진화한다.

---

## 10. TDD와 익스트림 프로그래밍(XP)의 관계

### 10.1 배경

Kent Beck은 TDD의 창시자이자 익스트림 프로그래밍(XP)의 창시자이기도 하다. TDD는 XP의 핵심 실천법 중 하나다.

### 10.2 XP의 실천법과 TDD

| XP 실천법 | TDD와의 관계 |
|-----------|-------------|
| **테스트 주도 개발 (TDD)** | XP의 핵심 실천법 자체 |
| **짝 프로그래밍 (Pair Programming)** | 한 사람이 테스트를 쓰고, 다른 사람이 구현을 쓰는 "핑퐁 TDD"가 효과적 |
| **리팩토링 (Refactoring)** | TDD 사이클의 세 번째 단계 |
| **지속적 통합 (CI)** | 모든 테스트가 항상 통과하는 상태를 유지 |
| **단순한 설계 (Simple Design)** | TDD가 자연스럽게 이끄는 방향 |
| **작은 릴리스 (Small Releases)** | 자주 테스트하고 자주 통합하면 자주 릴리스할 수 있다 |

### 10.3 TDD만으로도 가치가 있는가?

**그렇다.** TDD는 XP의 다른 실천법 없이도 독립적으로 가치가 있다. XP를 도입하지 않는 팀에서도 TDD만 실천하여 이점을 얻을 수 있다. Kent Beck은 "TDD는 XP의 가장 독립적인 실천법"이라고 평가한다.

물론 다른 XP 실천법과 결합하면 시너지가 생긴다. 특히 지속적 통합(CI)과의 결합은 거의 필수적이다 — 테스트를 작성했지만 통합 서버에서 실행하지 않는다면 가치의 상당 부분을 잃는다.

> **핵심 통찰**: TDD를 시작하기 위해 팀 전체가 XP를 도입할 필요는 없다. 개인 수준에서 TDD를 시작할 수 있으며, 그것만으로도 코드 품질과 개발 경험이 개선된다. 하지만 CI와의 결합은 강력히 권장된다.

---

## 11. 기존 코드에서 TDD를 시작하는 방법

### 11.1 Kent Beck의 조언

기존 레거시 코드에 TDD를 적용하는 것은 새 코드에 적용하는 것보다 훨씬 어렵다. Kent Beck의 현실적인 조언:

### 11.2 점진적 접근 전략

**전략 1: 변경할 부분을 감싸라**

```java
// 변경하고 싶은 레거시 코드가 있다
class OrderProcessor {
    void process(Order order) {
        // ... 수백 줄의 코드 ...
        // 여기를 바꾸고 싶다
        double tax = order.total * 0.08;
        // ... 더 많은 코드 ...
    }
}
```

```java
// 1단계: 변경할 부분에 대한 테스트를 작성
public void testTaxCalculation() {
    OrderProcessor processor = new OrderProcessor();
    // ... 현재 동작을 확인하는 테스트
}

// 2단계: 변경할 부분을 추출하고 테스트
public void testTaxCalculation() {
    assertEquals(8.0, calculateTax(100.0), 0.001);
}

// 3단계: 안전하게 변경
public void testTaxCalculation() {
    TaxPolicy policy = new DefaultTaxPolicy();
    assertEquals(8.0, policy.calculate(100.0), 0.001);
}
```

**전략 2: 새 코드부터 TDD로**

기존 코드를 전부 테스트하려 하지 말고, **새로 작성하는 코드부터** TDD를 적용한다. 시간이 지나면 테스트가 있는 코드의 비율이 점차 높아진다.

**전략 3: 버그를 테스트로 잡아라**

버그가 보고되면, 먼저 그 버그를 재현하는 테스트를 작성한다. 테스트가 실패하는 것을 확인한 후 버그를 수정한다. 이렇게 하면 자연스럽게 테스트가 축적된다.

### 11.3 현실적 조언

| 해야 할 것 | 하지 말아야 할 것 |
|-----------|----------------|
| 변경할 코드 주변에만 테스트 추가 | 전체 코드를 한 번에 테스트하려 하기 |
| 작은 성공을 축적 | 완벽한 커버리지를 목표로 삼기 |
| 새 코드부터 TDD 적용 | "나중에 한꺼번에 테스트 추가" 미루기 |
| 팀원과 TDD 경험 공유 | 혼자서 팀 전체의 관행을 바꾸려 하기 |

> **핵심 통찰**: 레거시 코드에서 TDD를 시작하는 핵심 원칙은 **"지금 변경하는 코드부터"**다. 과거에 작성된 모든 코드에 테스트를 추가하겠다는 것은 비현실적이다. 대신, 앞으로 변경하는 모든 코드에 테스트를 추가하면, 가장 자주 변경되는 코드(= 가장 중요한 코드)부터 테스트로 보호된다. Michael Feathers의 "Working Effectively with Legacy Code"가 이 주제를 깊이 다룬다.

---

## 12. Kent Beck의 마무리: TDD는 하나의 훈련이다

### 12.1 TDD는 기법이 아니라 습관이다

Kent Beck은 TDD를 단순한 테스트 기법이 아닌 **프로그래밍의 훈련(discipline)**으로 본다. 무술가가 기본 동작을 반복 연습하듯, 프로그래머는 Red → Green → Refactor 사이클을 반복 연습한다. 처음에는 어색하고 느리지만, 숙달되면 자연스러운 호흡이 된다.

### 12.2 TDD의 약속

Kent Beck이 TDD에 대해 약속하는 것:

1. **코드가 동작한다는 자신감**: "이 코드를 배포해도 괜찮은가?"에 "그렇다"고 답할 수 있다.
2. **두려움 없는 변경**: "이 부분을 리팩토링해도 될까?"에 "테스트가 있으니 된다"고 답할 수 있다.
3. **명확한 진행**: TODO 리스트의 항목이 하나씩 줄어가며, 진행 상황이 눈에 보인다.
4. **지속 가능한 속도**: 기술 부채 없이 일정한 속도로 기능을 추가할 수 있다.

### 12.3 TDD가 약속하지 않는 것

Kent Beck은 TDD의 한계도 인정한다:

- TDD는 **모든 버그를 잡지 못한다**. 작성하지 않은 테스트의 버그는 잡히지 않는다.
- TDD는 **요구사항을 파악해주지 않는다**. 잘못된 요구사항을 TDD로 구현하면, 잘못된 코드가 잘 동작하게 된다.
- TDD는 **성능을 보장하지 않는다**. 올바르게 동작하는 코드가 빠른 코드는 아니다.
- TDD는 **아키텍처를 결정하지 않는다**. 큰 그림의 설계 결정은 별도의 사고가 필요하다.

### 12.4 마지막 말

Kent Beck은 이 책을 통해 TDD가 "가르칠 수 있는 기술"임을 보여주려 했다. Part I과 Part II에서 실제 코딩 세션을 시연하고, Part III에서 패턴을 정리한 것은 독자가 **따라 하고, 연습하고, 자기 것으로 만들 수 있도록** 하기 위해서다.

TDD는 완벽한 방법론이 아니다. 하지만 프로그래밍에 대한 **자신감, 리듬, 즐거움**을 회복시켜 주는 도구이다. 코드에 대한 두려움을 지루함으로 바꾸는 — 그래서 "이 코드를 변경해도 될까?"라는 질문이 더 이상 두렵지 않은 — 그런 프로그래밍 방식이다.

> **핵심 통찰**: "깨끗한 코드가 동작한다(Clean code that works)." 이것이 TDD의 궁극적인 목표다. "동작하는 코드"를 먼저 만들고(Green), "깨끗한 코드"로 만든다(Refactor). 이 단순한 규율을 반복하면 "깨끗한 코드가 동작하는" 상태에 도달한다. 그리고 이것은 프로그래머로서 가장 만족스러운 상태다.

---

## 요약

- **단계의 크기**는 자신감에 비례한다. 확신이 있으면 크게, 불확실하면 작게. 언제든 작은 단계로 후퇴할 수 있다.
- **테스트 대상**은 "깨질 수 있는 모든 것"이다. 단순 getter/setter나 프레임워크 코드는 제외한다.
- **좋은 테스트**는 행위 변경에 민감하고 구조 변경에 둔감하다. 테스트 코드도 프로덕션 코드만큼 중요하다.
- **프레임워크**는 TDD를 통해 자연스럽게 발견된다. 미리 설계하지 않는다.
- **피드백 양**은 수확 체감의 법칙을 따른다. "테스트를 하나 더 추가했을 때 새로운 것을 배울 수 있는가?"가 기준이다.
- **테스트 삭제**는 두 테스트가 같은 것을 검증하고, 삭제해도 자신감이 줄지 않을 때 한다.
- **패턴**은 TDD에서 상향식으로 발견된다. 패턴 지식은 리팩토링의 방향을 잡는 데 도움이 된다.
- **TDD의 효과**는 결함 감소, 설계 피드백, 자신감, 문서화라는 네 축에서 나타난다.
- **XP와의 관계**: TDD는 XP의 실천법이지만, 독립적으로도 충분히 가치가 있다.
- **레거시 코드**: "지금 변경하는 코드부터" 테스트를 추가한다. 전체를 한 번에 테스트하려 하지 않는다.
- **TDD는 훈련**이다. 완벽한 방법론이 아니지만, 코드에 대한 자신감과 프로그래밍의 즐거움을 회복시키는 도구다.

---

## 다른 챕터와의 관계

- **Chapter 1~17 (Part I: Money Example)**: 이 챕터에서 논의한 "단계의 크기", "패턴의 발견", "프레임워크의 진화" 등 모든 주제의 구체적 사례가 Part I에 있다. Part I을 회고하면서 이 챕터를 읽으면 이해가 깊어진다.
- **Chapter 18~24 (Part II: xUnit Example)**: Part II는 "TDD로 테스트 프레임워크를 만들 수 있는가?"라는 질문에 대한 답이다. "TDD는 왜 효과적인가?"의 가장 강력한 증거가 Part II에 있다.
- **Chapter 25 (TDD Patterns)**: 이 챕터의 "무엇을 테스트할 것인가", "얼마나 테스트할 것인가"에 대한 구체적인 실천법이 25장의 TDD 패턴들이다.
- **Chapter 30 (Design Patterns)**: "TDD와 패턴의 관계"에서 논의한 "패턴의 상향식 발견"의 구체적 사례가 30장에 정리되어 있다.
- **Chapter 31 (Refactoring)**: "TDD는 왜 효과적인가?"의 답 중 하나인 "설계 피드백"은 31장의 리팩토링 패턴을 통해 구현된다. 리팩토링 능력이 곧 TDD의 효과를 결정한다.
